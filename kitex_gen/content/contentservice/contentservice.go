// Code generated by Kitex v0.8.0. DO NOT EDIT.

package contentservice

import (
	"context"
	content "github.com/CloudStriver/service-idl-gen-go/kitex_gen/content"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return contentServiceServiceInfo
}

var contentServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "ContentService"
	handlerType := (*content.ContentService)(nil)
	methods := map[string]kitex.MethodInfo{
		"GetCosInfo":                      kitex.NewMethodInfo(getCosInfoHandler, newGetCosInfoArgs, newGetCosInfoResult, false),
		"GetFileByMd5":                    kitex.NewMethodInfo(getFileByMd5Handler, newGetFileByMd5Args, newGetFileByMd5Result, false),
		"GetFileInfoByFileId":             kitex.NewMethodInfo(getFileInfoByFileIdHandler, newGetFileInfoByFileIdArgs, newGetFileInfoByFileIdResult, false),
		"GetFileByFileIdWithUserId":       kitex.NewMethodInfo(getFileByFileIdWithUserIdHandler, newGetFileByFileIdWithUserIdArgs, newGetFileByFileIdWithUserIdResult, false),
		"GetFileInfoByFileIds":            kitex.NewMethodInfo(getFileInfoByFileIdsHandler, newGetFileInfoByFileIdsArgs, newGetFileInfoByFileIdsResult, false),
		"GetFileInfoByFileIdsWithUserId":  kitex.NewMethodInfo(getFileInfoByFileIdsWithUserIdHandler, newGetFileInfoByFileIdsWithUserIdArgs, newGetFileInfoByFileIdsWithUserIdResult, false),
		"GetFilesByFatherId":              kitex.NewMethodInfo(getFilesByFatherIdHandler, newGetFilesByFatherIdArgs, newGetFilesByFatherIdResult, false),
		"GetFilesByFatherIdWithUserId":    kitex.NewMethodInfo(getFilesByFatherIdWithUserIdHandler, newGetFilesByFatherIdWithUserIdArgs, newGetFilesByFatherIdWithUserIdResult, false),
		"GetAllFileByFatherId":            kitex.NewMethodInfo(getAllFileByFatherIdHandler, newGetAllFileByFatherIdArgs, newGetAllFileByFatherIdResult, false),
		"GetFileCount":                    kitex.NewMethodInfo(getFileCountHandler, newGetFileCountArgs, newGetFileCountResult, false),
		"GetFileType":                     kitex.NewMethodInfo(getFileTypeHandler, newGetFileTypeArgs, newGetFileTypeResult, false),
		"GetFileInfoInPublicByFileId":     kitex.NewMethodInfo(getFileInfoInPublicByFileIdHandler, newGetFileInfoInPublicByFileIdArgs, newGetFileInfoInPublicByFileIdResult, false),
		"GetPublicFileByFileIdWithUserId": kitex.NewMethodInfo(getPublicFileByFileIdWithUserIdHandler, newGetPublicFileByFileIdWithUserIdArgs, newGetPublicFileByFileIdWithUserIdResult, false),
		"GetPublicByFileIds":              kitex.NewMethodInfo(getPublicByFileIdsHandler, newGetPublicByFileIdsArgs, newGetPublicByFileIdsResult, false),
		"GetPublicFilesByUserId":          kitex.NewMethodInfo(getPublicFilesByUserIdHandler, newGetPublicFilesByUserIdArgs, newGetPublicFilesByUserIdResult, false),
		"GetPublicFilesByFatherId":        kitex.NewMethodInfo(getPublicFilesByFatherIdHandler, newGetPublicFilesByFatherIdArgs, newGetPublicFilesByFatherIdResult, false),
		"GetAllPublicFileByFatherId":      kitex.NewMethodInfo(getAllPublicFileByFatherIdHandler, newGetAllPublicFileByFatherIdArgs, newGetAllPublicFileByFatherIdResult, false),
		"GetFileBySharingCode":            kitex.NewMethodInfo(getFileBySharingCodeHandler, newGetFileBySharingCodeArgs, newGetFileBySharingCodeResult, false),
		"CalFileSize":                     kitex.NewMethodInfo(calFileSizeHandler, newCalFileSizeArgs, newCalFileSizeResult, false),
		"CalPublicFileSize":               kitex.NewMethodInfo(calPublicFileSizeHandler, newCalPublicFileSizeArgs, newCalPublicFileSizeResult, false),
		"UploadFile":                      kitex.NewMethodInfo(uploadFileHandler, newUploadFileArgs, newUploadFileResult, false),
		"AskUploadFile":                   kitex.NewMethodInfo(askUploadFileHandler, newAskUploadFileArgs, newAskUploadFileResult, false),
		"AskUploadFileRollback":           kitex.NewMethodInfo(askUploadFileRollbackHandler, newAskUploadFileRollbackArgs, newAskUploadFileRollbackResult, false),
		"DeleteExpiredFiles":              kitex.NewMethodInfo(deleteExpiredFilesHandler, newDeleteExpiredFilesArgs, newDeleteExpiredFilesResult, false),
		"DeleteExpiredShareCodes":         kitex.NewMethodInfo(deleteExpiredShareCodesHandler, newDeleteExpiredShareCodesArgs, newDeleteExpiredShareCodesResult, false),
	}
	extra := map[string]interface{}{
		"PackageName":     "content",
		"ServiceFilePath": ``,
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.8.0",
		Extra:           extra,
	}
	return svcInfo
}

func getCosInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetCosInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetCosInfo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetCosInfoArgs:
		success, err := handler.(content.ContentService).GetCosInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetCosInfoResult)
		realResult.Success = success
	}
	return nil
}
func newGetCosInfoArgs() interface{} {
	return &GetCosInfoArgs{}
}

func newGetCosInfoResult() interface{} {
	return &GetCosInfoResult{}
}

type GetCosInfoArgs struct {
	Req *content.GetCosInfoReq
}

func (p *GetCosInfoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetCosInfoReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetCosInfoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetCosInfoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetCosInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetCosInfoArgs) Unmarshal(in []byte) error {
	msg := new(content.GetCosInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetCosInfoArgs_Req_DEFAULT *content.GetCosInfoReq

func (p *GetCosInfoArgs) GetReq() *content.GetCosInfoReq {
	if !p.IsSetReq() {
		return GetCosInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetCosInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetCosInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetCosInfoResult struct {
	Success *content.GetCosInfoResp
}

var GetCosInfoResult_Success_DEFAULT *content.GetCosInfoResp

func (p *GetCosInfoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetCosInfoResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetCosInfoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetCosInfoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetCosInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetCosInfoResult) Unmarshal(in []byte) error {
	msg := new(content.GetCosInfoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetCosInfoResult) GetSuccess() *content.GetCosInfoResp {
	if !p.IsSetSuccess() {
		return GetCosInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetCosInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetCosInfoResp)
}

func (p *GetCosInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetCosInfoResult) GetResult() interface{} {
	return p.Success
}

func getFileByMd5Handler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileByMd5Req)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileByMd5(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileByMd5Args:
		success, err := handler.(content.ContentService).GetFileByMd5(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileByMd5Result)
		realResult.Success = success
	}
	return nil
}
func newGetFileByMd5Args() interface{} {
	return &GetFileByMd5Args{}
}

func newGetFileByMd5Result() interface{} {
	return &GetFileByMd5Result{}
}

type GetFileByMd5Args struct {
	Req *content.GetFileByMd5Req
}

func (p *GetFileByMd5Args) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileByMd5Req)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileByMd5Args) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileByMd5Args) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileByMd5Args) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileByMd5Args) Unmarshal(in []byte) error {
	msg := new(content.GetFileByMd5Req)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileByMd5Args_Req_DEFAULT *content.GetFileByMd5Req

func (p *GetFileByMd5Args) GetReq() *content.GetFileByMd5Req {
	if !p.IsSetReq() {
		return GetFileByMd5Args_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileByMd5Args) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileByMd5Args) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileByMd5Result struct {
	Success *content.GetFileByMd5Resp
}

var GetFileByMd5Result_Success_DEFAULT *content.GetFileByMd5Resp

func (p *GetFileByMd5Result) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileByMd5Resp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileByMd5Result) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileByMd5Result) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileByMd5Result) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileByMd5Result) Unmarshal(in []byte) error {
	msg := new(content.GetFileByMd5Resp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileByMd5Result) GetSuccess() *content.GetFileByMd5Resp {
	if !p.IsSetSuccess() {
		return GetFileByMd5Result_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileByMd5Result) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileByMd5Resp)
}

func (p *GetFileByMd5Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileByMd5Result) GetResult() interface{} {
	return p.Success
}

func getFileInfoByFileIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileInfoByFileIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileInfoByFileId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileInfoByFileIdArgs:
		success, err := handler.(content.ContentService).GetFileInfoByFileId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileInfoByFileIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileInfoByFileIdArgs() interface{} {
	return &GetFileInfoByFileIdArgs{}
}

func newGetFileInfoByFileIdResult() interface{} {
	return &GetFileInfoByFileIdResult{}
}

type GetFileInfoByFileIdArgs struct {
	Req *content.GetFileInfoByFileIdReq
}

func (p *GetFileInfoByFileIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileInfoByFileIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileInfoByFileIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileInfoByFileIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileInfoByFileIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileInfoByFileIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoByFileIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileInfoByFileIdArgs_Req_DEFAULT *content.GetFileInfoByFileIdReq

func (p *GetFileInfoByFileIdArgs) GetReq() *content.GetFileInfoByFileIdReq {
	if !p.IsSetReq() {
		return GetFileInfoByFileIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileInfoByFileIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileInfoByFileIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileInfoByFileIdResult struct {
	Success *content.GetFileInfoByFileIdResp
}

var GetFileInfoByFileIdResult_Success_DEFAULT *content.GetFileInfoByFileIdResp

func (p *GetFileInfoByFileIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileInfoByFileIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileInfoByFileIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileInfoByFileIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileInfoByFileIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileInfoByFileIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoByFileIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileInfoByFileIdResult) GetSuccess() *content.GetFileInfoByFileIdResp {
	if !p.IsSetSuccess() {
		return GetFileInfoByFileIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileInfoByFileIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileInfoByFileIdResp)
}

func (p *GetFileInfoByFileIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileInfoByFileIdResult) GetResult() interface{} {
	return p.Success
}

func getFileByFileIdWithUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileByFileIdWithUserIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileByFileIdWithUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileByFileIdWithUserIdArgs:
		success, err := handler.(content.ContentService).GetFileByFileIdWithUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileByFileIdWithUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileByFileIdWithUserIdArgs() interface{} {
	return &GetFileByFileIdWithUserIdArgs{}
}

func newGetFileByFileIdWithUserIdResult() interface{} {
	return &GetFileByFileIdWithUserIdResult{}
}

type GetFileByFileIdWithUserIdArgs struct {
	Req *content.GetFileByFileIdWithUserIdReq
}

func (p *GetFileByFileIdWithUserIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileByFileIdWithUserIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileByFileIdWithUserIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileByFileIdWithUserIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileByFileIdWithUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileByFileIdWithUserIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileByFileIdWithUserIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileByFileIdWithUserIdArgs_Req_DEFAULT *content.GetFileByFileIdWithUserIdReq

func (p *GetFileByFileIdWithUserIdArgs) GetReq() *content.GetFileByFileIdWithUserIdReq {
	if !p.IsSetReq() {
		return GetFileByFileIdWithUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileByFileIdWithUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileByFileIdWithUserIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileByFileIdWithUserIdResult struct {
	Success *content.GetFileByFileIdWithUserIdResp
}

var GetFileByFileIdWithUserIdResult_Success_DEFAULT *content.GetFileByFileIdWithUserIdResp

func (p *GetFileByFileIdWithUserIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileByFileIdWithUserIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileByFileIdWithUserIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileByFileIdWithUserIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileByFileIdWithUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileByFileIdWithUserIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileByFileIdWithUserIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileByFileIdWithUserIdResult) GetSuccess() *content.GetFileByFileIdWithUserIdResp {
	if !p.IsSetSuccess() {
		return GetFileByFileIdWithUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileByFileIdWithUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileByFileIdWithUserIdResp)
}

func (p *GetFileByFileIdWithUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileByFileIdWithUserIdResult) GetResult() interface{} {
	return p.Success
}

func getFileInfoByFileIdsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileInfoByFileIdsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileInfoByFileIds(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileInfoByFileIdsArgs:
		success, err := handler.(content.ContentService).GetFileInfoByFileIds(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileInfoByFileIdsResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileInfoByFileIdsArgs() interface{} {
	return &GetFileInfoByFileIdsArgs{}
}

func newGetFileInfoByFileIdsResult() interface{} {
	return &GetFileInfoByFileIdsResult{}
}

type GetFileInfoByFileIdsArgs struct {
	Req *content.GetFileInfoByFileIdsReq
}

func (p *GetFileInfoByFileIdsArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileInfoByFileIdsReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileInfoByFileIdsArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileInfoByFileIdsArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileInfoByFileIdsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileInfoByFileIdsArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoByFileIdsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileInfoByFileIdsArgs_Req_DEFAULT *content.GetFileInfoByFileIdsReq

func (p *GetFileInfoByFileIdsArgs) GetReq() *content.GetFileInfoByFileIdsReq {
	if !p.IsSetReq() {
		return GetFileInfoByFileIdsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileInfoByFileIdsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileInfoByFileIdsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileInfoByFileIdsResult struct {
	Success *content.GetFileInfoByFileIdsResp
}

var GetFileInfoByFileIdsResult_Success_DEFAULT *content.GetFileInfoByFileIdsResp

func (p *GetFileInfoByFileIdsResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileInfoByFileIdsResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileInfoByFileIdsResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileInfoByFileIdsResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileInfoByFileIdsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileInfoByFileIdsResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoByFileIdsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileInfoByFileIdsResult) GetSuccess() *content.GetFileInfoByFileIdsResp {
	if !p.IsSetSuccess() {
		return GetFileInfoByFileIdsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileInfoByFileIdsResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileInfoByFileIdsResp)
}

func (p *GetFileInfoByFileIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileInfoByFileIdsResult) GetResult() interface{} {
	return p.Success
}

func getFileInfoByFileIdsWithUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileInfoByFileIdsWithUserIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileInfoByFileIdsWithUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileInfoByFileIdsWithUserIdArgs:
		success, err := handler.(content.ContentService).GetFileInfoByFileIdsWithUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileInfoByFileIdsWithUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileInfoByFileIdsWithUserIdArgs() interface{} {
	return &GetFileInfoByFileIdsWithUserIdArgs{}
}

func newGetFileInfoByFileIdsWithUserIdResult() interface{} {
	return &GetFileInfoByFileIdsWithUserIdResult{}
}

type GetFileInfoByFileIdsWithUserIdArgs struct {
	Req *content.GetFileInfoByFileIdsWithUserIdReq
}

func (p *GetFileInfoByFileIdsWithUserIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileInfoByFileIdsWithUserIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileInfoByFileIdsWithUserIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileInfoByFileIdsWithUserIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileInfoByFileIdsWithUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileInfoByFileIdsWithUserIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoByFileIdsWithUserIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileInfoByFileIdsWithUserIdArgs_Req_DEFAULT *content.GetFileInfoByFileIdsWithUserIdReq

func (p *GetFileInfoByFileIdsWithUserIdArgs) GetReq() *content.GetFileInfoByFileIdsWithUserIdReq {
	if !p.IsSetReq() {
		return GetFileInfoByFileIdsWithUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileInfoByFileIdsWithUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileInfoByFileIdsWithUserIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileInfoByFileIdsWithUserIdResult struct {
	Success *content.GetFileInfoByFileIdsWithUserIdResp
}

var GetFileInfoByFileIdsWithUserIdResult_Success_DEFAULT *content.GetFileInfoByFileIdsWithUserIdResp

func (p *GetFileInfoByFileIdsWithUserIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileInfoByFileIdsWithUserIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileInfoByFileIdsWithUserIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileInfoByFileIdsWithUserIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileInfoByFileIdsWithUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileInfoByFileIdsWithUserIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoByFileIdsWithUserIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileInfoByFileIdsWithUserIdResult) GetSuccess() *content.GetFileInfoByFileIdsWithUserIdResp {
	if !p.IsSetSuccess() {
		return GetFileInfoByFileIdsWithUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileInfoByFileIdsWithUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileInfoByFileIdsWithUserIdResp)
}

func (p *GetFileInfoByFileIdsWithUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileInfoByFileIdsWithUserIdResult) GetResult() interface{} {
	return p.Success
}

func getFilesByFatherIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFilesByFatherIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFilesByFatherId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFilesByFatherIdArgs:
		success, err := handler.(content.ContentService).GetFilesByFatherId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFilesByFatherIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetFilesByFatherIdArgs() interface{} {
	return &GetFilesByFatherIdArgs{}
}

func newGetFilesByFatherIdResult() interface{} {
	return &GetFilesByFatherIdResult{}
}

type GetFilesByFatherIdArgs struct {
	Req *content.GetFilesByFatherIdReq
}

func (p *GetFilesByFatherIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFilesByFatherIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFilesByFatherIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFilesByFatherIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFilesByFatherIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFilesByFatherIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFilesByFatherIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFilesByFatherIdArgs_Req_DEFAULT *content.GetFilesByFatherIdReq

func (p *GetFilesByFatherIdArgs) GetReq() *content.GetFilesByFatherIdReq {
	if !p.IsSetReq() {
		return GetFilesByFatherIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFilesByFatherIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFilesByFatherIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFilesByFatherIdResult struct {
	Success *content.GetFilesByFatherIdResp
}

var GetFilesByFatherIdResult_Success_DEFAULT *content.GetFilesByFatherIdResp

func (p *GetFilesByFatherIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFilesByFatherIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFilesByFatherIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFilesByFatherIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFilesByFatherIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFilesByFatherIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetFilesByFatherIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFilesByFatherIdResult) GetSuccess() *content.GetFilesByFatherIdResp {
	if !p.IsSetSuccess() {
		return GetFilesByFatherIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFilesByFatherIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFilesByFatherIdResp)
}

func (p *GetFilesByFatherIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFilesByFatherIdResult) GetResult() interface{} {
	return p.Success
}

func getFilesByFatherIdWithUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFilesByFatherIdWithUserIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFilesByFatherIdWithUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFilesByFatherIdWithUserIdArgs:
		success, err := handler.(content.ContentService).GetFilesByFatherIdWithUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFilesByFatherIdWithUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetFilesByFatherIdWithUserIdArgs() interface{} {
	return &GetFilesByFatherIdWithUserIdArgs{}
}

func newGetFilesByFatherIdWithUserIdResult() interface{} {
	return &GetFilesByFatherIdWithUserIdResult{}
}

type GetFilesByFatherIdWithUserIdArgs struct {
	Req *content.GetFilesByFatherIdWithUserIdReq
}

func (p *GetFilesByFatherIdWithUserIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFilesByFatherIdWithUserIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFilesByFatherIdWithUserIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFilesByFatherIdWithUserIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFilesByFatherIdWithUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFilesByFatherIdWithUserIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFilesByFatherIdWithUserIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFilesByFatherIdWithUserIdArgs_Req_DEFAULT *content.GetFilesByFatherIdWithUserIdReq

func (p *GetFilesByFatherIdWithUserIdArgs) GetReq() *content.GetFilesByFatherIdWithUserIdReq {
	if !p.IsSetReq() {
		return GetFilesByFatherIdWithUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFilesByFatherIdWithUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFilesByFatherIdWithUserIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFilesByFatherIdWithUserIdResult struct {
	Success *content.GetFilesByFatherIdWithUserIdResp
}

var GetFilesByFatherIdWithUserIdResult_Success_DEFAULT *content.GetFilesByFatherIdWithUserIdResp

func (p *GetFilesByFatherIdWithUserIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFilesByFatherIdWithUserIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFilesByFatherIdWithUserIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFilesByFatherIdWithUserIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFilesByFatherIdWithUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFilesByFatherIdWithUserIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetFilesByFatherIdWithUserIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFilesByFatherIdWithUserIdResult) GetSuccess() *content.GetFilesByFatherIdWithUserIdResp {
	if !p.IsSetSuccess() {
		return GetFilesByFatherIdWithUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFilesByFatherIdWithUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFilesByFatherIdWithUserIdResp)
}

func (p *GetFilesByFatherIdWithUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFilesByFatherIdWithUserIdResult) GetResult() interface{} {
	return p.Success
}

func getAllFileByFatherIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetAllFileByFatherIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetAllFileByFatherId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetAllFileByFatherIdArgs:
		success, err := handler.(content.ContentService).GetAllFileByFatherId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetAllFileByFatherIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetAllFileByFatherIdArgs() interface{} {
	return &GetAllFileByFatherIdArgs{}
}

func newGetAllFileByFatherIdResult() interface{} {
	return &GetAllFileByFatherIdResult{}
}

type GetAllFileByFatherIdArgs struct {
	Req *content.GetAllFileByFatherIdReq
}

func (p *GetAllFileByFatherIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetAllFileByFatherIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetAllFileByFatherIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetAllFileByFatherIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetAllFileByFatherIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetAllFileByFatherIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetAllFileByFatherIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetAllFileByFatherIdArgs_Req_DEFAULT *content.GetAllFileByFatherIdReq

func (p *GetAllFileByFatherIdArgs) GetReq() *content.GetAllFileByFatherIdReq {
	if !p.IsSetReq() {
		return GetAllFileByFatherIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetAllFileByFatherIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetAllFileByFatherIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetAllFileByFatherIdResult struct {
	Success *content.GetAllFileByFatherIdResp
}

var GetAllFileByFatherIdResult_Success_DEFAULT *content.GetAllFileByFatherIdResp

func (p *GetAllFileByFatherIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetAllFileByFatherIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetAllFileByFatherIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetAllFileByFatherIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetAllFileByFatherIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetAllFileByFatherIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetAllFileByFatherIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetAllFileByFatherIdResult) GetSuccess() *content.GetAllFileByFatherIdResp {
	if !p.IsSetSuccess() {
		return GetAllFileByFatherIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetAllFileByFatherIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetAllFileByFatherIdResp)
}

func (p *GetAllFileByFatherIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetAllFileByFatherIdResult) GetResult() interface{} {
	return p.Success
}

func getFileCountHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileCountReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileCount(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileCountArgs:
		success, err := handler.(content.ContentService).GetFileCount(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileCountResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileCountArgs() interface{} {
	return &GetFileCountArgs{}
}

func newGetFileCountResult() interface{} {
	return &GetFileCountResult{}
}

type GetFileCountArgs struct {
	Req *content.GetFileCountReq
}

func (p *GetFileCountArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileCountReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileCountArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileCountArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileCountArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileCountArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileCountReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileCountArgs_Req_DEFAULT *content.GetFileCountReq

func (p *GetFileCountArgs) GetReq() *content.GetFileCountReq {
	if !p.IsSetReq() {
		return GetFileCountArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileCountArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileCountArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileCountResult struct {
	Success *content.GetFileCountResp
}

var GetFileCountResult_Success_DEFAULT *content.GetFileCountResp

func (p *GetFileCountResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileCountResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileCountResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileCountResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileCountResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileCountResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileCountResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileCountResult) GetSuccess() *content.GetFileCountResp {
	if !p.IsSetSuccess() {
		return GetFileCountResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileCountResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileCountResp)
}

func (p *GetFileCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileCountResult) GetResult() interface{} {
	return p.Success
}

func getFileTypeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileTypeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileType(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileTypeArgs:
		success, err := handler.(content.ContentService).GetFileType(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileTypeResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileTypeArgs() interface{} {
	return &GetFileTypeArgs{}
}

func newGetFileTypeResult() interface{} {
	return &GetFileTypeResult{}
}

type GetFileTypeArgs struct {
	Req *content.GetFileTypeReq
}

func (p *GetFileTypeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileTypeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileTypeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileTypeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileTypeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileTypeArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileTypeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileTypeArgs_Req_DEFAULT *content.GetFileTypeReq

func (p *GetFileTypeArgs) GetReq() *content.GetFileTypeReq {
	if !p.IsSetReq() {
		return GetFileTypeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileTypeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileTypeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileTypeResult struct {
	Success *content.GetFileTypeReq
}

var GetFileTypeResult_Success_DEFAULT *content.GetFileTypeReq

func (p *GetFileTypeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileTypeReq)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileTypeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileTypeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileTypeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileTypeResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileTypeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileTypeResult) GetSuccess() *content.GetFileTypeReq {
	if !p.IsSetSuccess() {
		return GetFileTypeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileTypeResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileTypeReq)
}

func (p *GetFileTypeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileTypeResult) GetResult() interface{} {
	return p.Success
}

func getFileInfoInPublicByFileIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileInfoInPublicByFileIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileInfoInPublicByFileId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileInfoInPublicByFileIdArgs:
		success, err := handler.(content.ContentService).GetFileInfoInPublicByFileId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileInfoInPublicByFileIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileInfoInPublicByFileIdArgs() interface{} {
	return &GetFileInfoInPublicByFileIdArgs{}
}

func newGetFileInfoInPublicByFileIdResult() interface{} {
	return &GetFileInfoInPublicByFileIdResult{}
}

type GetFileInfoInPublicByFileIdArgs struct {
	Req *content.GetFileInfoInPublicByFileIdReq
}

func (p *GetFileInfoInPublicByFileIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileInfoInPublicByFileIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileInfoInPublicByFileIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileInfoInPublicByFileIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileInfoInPublicByFileIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileInfoInPublicByFileIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoInPublicByFileIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileInfoInPublicByFileIdArgs_Req_DEFAULT *content.GetFileInfoInPublicByFileIdReq

func (p *GetFileInfoInPublicByFileIdArgs) GetReq() *content.GetFileInfoInPublicByFileIdReq {
	if !p.IsSetReq() {
		return GetFileInfoInPublicByFileIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileInfoInPublicByFileIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileInfoInPublicByFileIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileInfoInPublicByFileIdResult struct {
	Success *content.GetFileInfoInPublicByFileIdResp
}

var GetFileInfoInPublicByFileIdResult_Success_DEFAULT *content.GetFileInfoInPublicByFileIdResp

func (p *GetFileInfoInPublicByFileIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileInfoInPublicByFileIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileInfoInPublicByFileIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileInfoInPublicByFileIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileInfoInPublicByFileIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileInfoInPublicByFileIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileInfoInPublicByFileIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileInfoInPublicByFileIdResult) GetSuccess() *content.GetFileInfoInPublicByFileIdResp {
	if !p.IsSetSuccess() {
		return GetFileInfoInPublicByFileIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileInfoInPublicByFileIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileInfoInPublicByFileIdResp)
}

func (p *GetFileInfoInPublicByFileIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileInfoInPublicByFileIdResult) GetResult() interface{} {
	return p.Success
}

func getPublicFileByFileIdWithUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetPublicFileByFileIdWithUserIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetPublicFileByFileIdWithUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetPublicFileByFileIdWithUserIdArgs:
		success, err := handler.(content.ContentService).GetPublicFileByFileIdWithUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPublicFileByFileIdWithUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetPublicFileByFileIdWithUserIdArgs() interface{} {
	return &GetPublicFileByFileIdWithUserIdArgs{}
}

func newGetPublicFileByFileIdWithUserIdResult() interface{} {
	return &GetPublicFileByFileIdWithUserIdResult{}
}

type GetPublicFileByFileIdWithUserIdArgs struct {
	Req *content.GetPublicFileByFileIdWithUserIdReq
}

func (p *GetPublicFileByFileIdWithUserIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetPublicFileByFileIdWithUserIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetPublicFileByFileIdWithUserIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetPublicFileByFileIdWithUserIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetPublicFileByFileIdWithUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetPublicFileByFileIdWithUserIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetPublicFileByFileIdWithUserIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPublicFileByFileIdWithUserIdArgs_Req_DEFAULT *content.GetPublicFileByFileIdWithUserIdReq

func (p *GetPublicFileByFileIdWithUserIdArgs) GetReq() *content.GetPublicFileByFileIdWithUserIdReq {
	if !p.IsSetReq() {
		return GetPublicFileByFileIdWithUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPublicFileByFileIdWithUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetPublicFileByFileIdWithUserIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetPublicFileByFileIdWithUserIdResult struct {
	Success *content.GetPublicFileByFileIdWithUserIdResp
}

var GetPublicFileByFileIdWithUserIdResult_Success_DEFAULT *content.GetPublicFileByFileIdWithUserIdResp

func (p *GetPublicFileByFileIdWithUserIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetPublicFileByFileIdWithUserIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetPublicFileByFileIdWithUserIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetPublicFileByFileIdWithUserIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetPublicFileByFileIdWithUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetPublicFileByFileIdWithUserIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetPublicFileByFileIdWithUserIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPublicFileByFileIdWithUserIdResult) GetSuccess() *content.GetPublicFileByFileIdWithUserIdResp {
	if !p.IsSetSuccess() {
		return GetPublicFileByFileIdWithUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPublicFileByFileIdWithUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetPublicFileByFileIdWithUserIdResp)
}

func (p *GetPublicFileByFileIdWithUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPublicFileByFileIdWithUserIdResult) GetResult() interface{} {
	return p.Success
}

func getPublicByFileIdsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetPublicByFileIdsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetPublicByFileIds(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetPublicByFileIdsArgs:
		success, err := handler.(content.ContentService).GetPublicByFileIds(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPublicByFileIdsResult)
		realResult.Success = success
	}
	return nil
}
func newGetPublicByFileIdsArgs() interface{} {
	return &GetPublicByFileIdsArgs{}
}

func newGetPublicByFileIdsResult() interface{} {
	return &GetPublicByFileIdsResult{}
}

type GetPublicByFileIdsArgs struct {
	Req *content.GetPublicByFileIdsReq
}

func (p *GetPublicByFileIdsArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetPublicByFileIdsReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetPublicByFileIdsArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetPublicByFileIdsArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetPublicByFileIdsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetPublicByFileIdsArgs) Unmarshal(in []byte) error {
	msg := new(content.GetPublicByFileIdsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPublicByFileIdsArgs_Req_DEFAULT *content.GetPublicByFileIdsReq

func (p *GetPublicByFileIdsArgs) GetReq() *content.GetPublicByFileIdsReq {
	if !p.IsSetReq() {
		return GetPublicByFileIdsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPublicByFileIdsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetPublicByFileIdsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetPublicByFileIdsResult struct {
	Success *content.GetPublicByFileIdsResp
}

var GetPublicByFileIdsResult_Success_DEFAULT *content.GetPublicByFileIdsResp

func (p *GetPublicByFileIdsResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetPublicByFileIdsResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetPublicByFileIdsResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetPublicByFileIdsResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetPublicByFileIdsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetPublicByFileIdsResult) Unmarshal(in []byte) error {
	msg := new(content.GetPublicByFileIdsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPublicByFileIdsResult) GetSuccess() *content.GetPublicByFileIdsResp {
	if !p.IsSetSuccess() {
		return GetPublicByFileIdsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPublicByFileIdsResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetPublicByFileIdsResp)
}

func (p *GetPublicByFileIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPublicByFileIdsResult) GetResult() interface{} {
	return p.Success
}

func getPublicFilesByUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetPublicFilesByUserIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetPublicFilesByUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetPublicFilesByUserIdArgs:
		success, err := handler.(content.ContentService).GetPublicFilesByUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPublicFilesByUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetPublicFilesByUserIdArgs() interface{} {
	return &GetPublicFilesByUserIdArgs{}
}

func newGetPublicFilesByUserIdResult() interface{} {
	return &GetPublicFilesByUserIdResult{}
}

type GetPublicFilesByUserIdArgs struct {
	Req *content.GetPublicFilesByUserIdReq
}

func (p *GetPublicFilesByUserIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetPublicFilesByUserIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetPublicFilesByUserIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetPublicFilesByUserIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetPublicFilesByUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetPublicFilesByUserIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetPublicFilesByUserIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPublicFilesByUserIdArgs_Req_DEFAULT *content.GetPublicFilesByUserIdReq

func (p *GetPublicFilesByUserIdArgs) GetReq() *content.GetPublicFilesByUserIdReq {
	if !p.IsSetReq() {
		return GetPublicFilesByUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPublicFilesByUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetPublicFilesByUserIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetPublicFilesByUserIdResult struct {
	Success *content.GetPublicFilesByUserIdResp
}

var GetPublicFilesByUserIdResult_Success_DEFAULT *content.GetPublicFilesByUserIdResp

func (p *GetPublicFilesByUserIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetPublicFilesByUserIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetPublicFilesByUserIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetPublicFilesByUserIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetPublicFilesByUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetPublicFilesByUserIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetPublicFilesByUserIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPublicFilesByUserIdResult) GetSuccess() *content.GetPublicFilesByUserIdResp {
	if !p.IsSetSuccess() {
		return GetPublicFilesByUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPublicFilesByUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetPublicFilesByUserIdResp)
}

func (p *GetPublicFilesByUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPublicFilesByUserIdResult) GetResult() interface{} {
	return p.Success
}

func getPublicFilesByFatherIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetPublicFilesByFatherIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetPublicFilesByFatherId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetPublicFilesByFatherIdArgs:
		success, err := handler.(content.ContentService).GetPublicFilesByFatherId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPublicFilesByFatherIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetPublicFilesByFatherIdArgs() interface{} {
	return &GetPublicFilesByFatherIdArgs{}
}

func newGetPublicFilesByFatherIdResult() interface{} {
	return &GetPublicFilesByFatherIdResult{}
}

type GetPublicFilesByFatherIdArgs struct {
	Req *content.GetPublicFilesByFatherIdReq
}

func (p *GetPublicFilesByFatherIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetPublicFilesByFatherIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetPublicFilesByFatherIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetPublicFilesByFatherIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetPublicFilesByFatherIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetPublicFilesByFatherIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetPublicFilesByFatherIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPublicFilesByFatherIdArgs_Req_DEFAULT *content.GetPublicFilesByFatherIdReq

func (p *GetPublicFilesByFatherIdArgs) GetReq() *content.GetPublicFilesByFatherIdReq {
	if !p.IsSetReq() {
		return GetPublicFilesByFatherIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPublicFilesByFatherIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetPublicFilesByFatherIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetPublicFilesByFatherIdResult struct {
	Success *content.GetPublicFilesByFatherIdResp
}

var GetPublicFilesByFatherIdResult_Success_DEFAULT *content.GetPublicFilesByFatherIdResp

func (p *GetPublicFilesByFatherIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetPublicFilesByFatherIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetPublicFilesByFatherIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetPublicFilesByFatherIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetPublicFilesByFatherIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetPublicFilesByFatherIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetPublicFilesByFatherIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPublicFilesByFatherIdResult) GetSuccess() *content.GetPublicFilesByFatherIdResp {
	if !p.IsSetSuccess() {
		return GetPublicFilesByFatherIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPublicFilesByFatherIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetPublicFilesByFatherIdResp)
}

func (p *GetPublicFilesByFatherIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPublicFilesByFatherIdResult) GetResult() interface{} {
	return p.Success
}

func getAllPublicFileByFatherIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetAllPublicFileByFatherIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetAllPublicFileByFatherId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetAllPublicFileByFatherIdArgs:
		success, err := handler.(content.ContentService).GetAllPublicFileByFatherId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetAllPublicFileByFatherIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetAllPublicFileByFatherIdArgs() interface{} {
	return &GetAllPublicFileByFatherIdArgs{}
}

func newGetAllPublicFileByFatherIdResult() interface{} {
	return &GetAllPublicFileByFatherIdResult{}
}

type GetAllPublicFileByFatherIdArgs struct {
	Req *content.GetAllPublicFileByFatherIdReq
}

func (p *GetAllPublicFileByFatherIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetAllPublicFileByFatherIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetAllPublicFileByFatherIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetAllPublicFileByFatherIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetAllPublicFileByFatherIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetAllPublicFileByFatherIdArgs) Unmarshal(in []byte) error {
	msg := new(content.GetAllPublicFileByFatherIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetAllPublicFileByFatherIdArgs_Req_DEFAULT *content.GetAllPublicFileByFatherIdReq

func (p *GetAllPublicFileByFatherIdArgs) GetReq() *content.GetAllPublicFileByFatherIdReq {
	if !p.IsSetReq() {
		return GetAllPublicFileByFatherIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetAllPublicFileByFatherIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetAllPublicFileByFatherIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetAllPublicFileByFatherIdResult struct {
	Success *content.GetAllPublicFileByFatherIdResp
}

var GetAllPublicFileByFatherIdResult_Success_DEFAULT *content.GetAllPublicFileByFatherIdResp

func (p *GetAllPublicFileByFatherIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetAllPublicFileByFatherIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetAllPublicFileByFatherIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetAllPublicFileByFatherIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetAllPublicFileByFatherIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetAllPublicFileByFatherIdResult) Unmarshal(in []byte) error {
	msg := new(content.GetAllPublicFileByFatherIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetAllPublicFileByFatherIdResult) GetSuccess() *content.GetAllPublicFileByFatherIdResp {
	if !p.IsSetSuccess() {
		return GetAllPublicFileByFatherIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetAllPublicFileByFatherIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetAllPublicFileByFatherIdResp)
}

func (p *GetAllPublicFileByFatherIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetAllPublicFileByFatherIdResult) GetResult() interface{} {
	return p.Success
}

func getFileBySharingCodeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileBySharingCodeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileBySharingCode(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileBySharingCodeArgs:
		success, err := handler.(content.ContentService).GetFileBySharingCode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileBySharingCodeResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileBySharingCodeArgs() interface{} {
	return &GetFileBySharingCodeArgs{}
}

func newGetFileBySharingCodeResult() interface{} {
	return &GetFileBySharingCodeResult{}
}

type GetFileBySharingCodeArgs struct {
	Req *content.GetFileBySharingCodeReq
}

func (p *GetFileBySharingCodeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileBySharingCodeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileBySharingCodeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileBySharingCodeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileBySharingCodeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileBySharingCodeArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileBySharingCodeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileBySharingCodeArgs_Req_DEFAULT *content.GetFileBySharingCodeReq

func (p *GetFileBySharingCodeArgs) GetReq() *content.GetFileBySharingCodeReq {
	if !p.IsSetReq() {
		return GetFileBySharingCodeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileBySharingCodeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileBySharingCodeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileBySharingCodeResult struct {
	Success *content.GetFileBySharingCodeResp
}

var GetFileBySharingCodeResult_Success_DEFAULT *content.GetFileBySharingCodeResp

func (p *GetFileBySharingCodeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileBySharingCodeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileBySharingCodeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileBySharingCodeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileBySharingCodeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileBySharingCodeResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileBySharingCodeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileBySharingCodeResult) GetSuccess() *content.GetFileBySharingCodeResp {
	if !p.IsSetSuccess() {
		return GetFileBySharingCodeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileBySharingCodeResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileBySharingCodeResp)
}

func (p *GetFileBySharingCodeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileBySharingCodeResult) GetResult() interface{} {
	return p.Success
}

func calFileSizeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CalFileSizeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CalFileSize(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CalFileSizeArgs:
		success, err := handler.(content.ContentService).CalFileSize(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CalFileSizeResult)
		realResult.Success = success
	}
	return nil
}
func newCalFileSizeArgs() interface{} {
	return &CalFileSizeArgs{}
}

func newCalFileSizeResult() interface{} {
	return &CalFileSizeResult{}
}

type CalFileSizeArgs struct {
	Req *content.CalFileSizeReq
}

func (p *CalFileSizeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CalFileSizeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CalFileSizeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CalFileSizeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CalFileSizeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CalFileSizeArgs) Unmarshal(in []byte) error {
	msg := new(content.CalFileSizeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CalFileSizeArgs_Req_DEFAULT *content.CalFileSizeReq

func (p *CalFileSizeArgs) GetReq() *content.CalFileSizeReq {
	if !p.IsSetReq() {
		return CalFileSizeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CalFileSizeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CalFileSizeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CalFileSizeResult struct {
	Success *content.CalFileSizeResp
}

var CalFileSizeResult_Success_DEFAULT *content.CalFileSizeResp

func (p *CalFileSizeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CalFileSizeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CalFileSizeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CalFileSizeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CalFileSizeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CalFileSizeResult) Unmarshal(in []byte) error {
	msg := new(content.CalFileSizeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CalFileSizeResult) GetSuccess() *content.CalFileSizeResp {
	if !p.IsSetSuccess() {
		return CalFileSizeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CalFileSizeResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CalFileSizeResp)
}

func (p *CalFileSizeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CalFileSizeResult) GetResult() interface{} {
	return p.Success
}

func calPublicFileSizeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CalPublicFileSizeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CalPublicFileSize(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CalPublicFileSizeArgs:
		success, err := handler.(content.ContentService).CalPublicFileSize(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CalPublicFileSizeResult)
		realResult.Success = success
	}
	return nil
}
func newCalPublicFileSizeArgs() interface{} {
	return &CalPublicFileSizeArgs{}
}

func newCalPublicFileSizeResult() interface{} {
	return &CalPublicFileSizeResult{}
}

type CalPublicFileSizeArgs struct {
	Req *content.CalPublicFileSizeReq
}

func (p *CalPublicFileSizeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CalPublicFileSizeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CalPublicFileSizeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CalPublicFileSizeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CalPublicFileSizeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CalPublicFileSizeArgs) Unmarshal(in []byte) error {
	msg := new(content.CalPublicFileSizeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CalPublicFileSizeArgs_Req_DEFAULT *content.CalPublicFileSizeReq

func (p *CalPublicFileSizeArgs) GetReq() *content.CalPublicFileSizeReq {
	if !p.IsSetReq() {
		return CalPublicFileSizeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CalPublicFileSizeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CalPublicFileSizeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CalPublicFileSizeResult struct {
	Success *content.CalPublicFileSizeResp
}

var CalPublicFileSizeResult_Success_DEFAULT *content.CalPublicFileSizeResp

func (p *CalPublicFileSizeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CalPublicFileSizeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CalPublicFileSizeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CalPublicFileSizeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CalPublicFileSizeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CalPublicFileSizeResult) Unmarshal(in []byte) error {
	msg := new(content.CalPublicFileSizeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CalPublicFileSizeResult) GetSuccess() *content.CalPublicFileSizeResp {
	if !p.IsSetSuccess() {
		return CalPublicFileSizeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CalPublicFileSizeResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CalPublicFileSizeResp)
}

func (p *CalPublicFileSizeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CalPublicFileSizeResult) GetResult() interface{} {
	return p.Success
}

func uploadFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.UploadFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).UploadFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UploadFileArgs:
		success, err := handler.(content.ContentService).UploadFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UploadFileResult)
		realResult.Success = success
	}
	return nil
}
func newUploadFileArgs() interface{} {
	return &UploadFileArgs{}
}

func newUploadFileResult() interface{} {
	return &UploadFileResult{}
}

type UploadFileArgs struct {
	Req *content.UploadFileReq
}

func (p *UploadFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.UploadFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UploadFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UploadFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UploadFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UploadFileArgs) Unmarshal(in []byte) error {
	msg := new(content.UploadFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadFileArgs_Req_DEFAULT *content.UploadFileReq

func (p *UploadFileArgs) GetReq() *content.UploadFileReq {
	if !p.IsSetReq() {
		return UploadFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UploadFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UploadFileResult struct {
	Success *content.UploadFileResp
}

var UploadFileResult_Success_DEFAULT *content.UploadFileResp

func (p *UploadFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.UploadFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UploadFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UploadFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UploadFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UploadFileResult) Unmarshal(in []byte) error {
	msg := new(content.UploadFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadFileResult) GetSuccess() *content.UploadFileResp {
	if !p.IsSetSuccess() {
		return UploadFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.UploadFileResp)
}

func (p *UploadFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UploadFileResult) GetResult() interface{} {
	return p.Success
}

func askUploadFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.AskUploadFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).AskUploadFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AskUploadFileArgs:
		success, err := handler.(content.ContentService).AskUploadFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AskUploadFileResult)
		realResult.Success = success
	}
	return nil
}
func newAskUploadFileArgs() interface{} {
	return &AskUploadFileArgs{}
}

func newAskUploadFileResult() interface{} {
	return &AskUploadFileResult{}
}

type AskUploadFileArgs struct {
	Req *content.AskUploadFileReq
}

func (p *AskUploadFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.AskUploadFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AskUploadFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AskUploadFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AskUploadFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AskUploadFileArgs) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AskUploadFileArgs_Req_DEFAULT *content.AskUploadFileReq

func (p *AskUploadFileArgs) GetReq() *content.AskUploadFileReq {
	if !p.IsSetReq() {
		return AskUploadFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AskUploadFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AskUploadFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AskUploadFileResult struct {
	Success *content.AskUploadFileResp
}

var AskUploadFileResult_Success_DEFAULT *content.AskUploadFileResp

func (p *AskUploadFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.AskUploadFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AskUploadFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AskUploadFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AskUploadFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AskUploadFileResult) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AskUploadFileResult) GetSuccess() *content.AskUploadFileResp {
	if !p.IsSetSuccess() {
		return AskUploadFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AskUploadFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.AskUploadFileResp)
}

func (p *AskUploadFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AskUploadFileResult) GetResult() interface{} {
	return p.Success
}

func askUploadFileRollbackHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.AskUploadFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).AskUploadFileRollback(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AskUploadFileRollbackArgs:
		success, err := handler.(content.ContentService).AskUploadFileRollback(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AskUploadFileRollbackResult)
		realResult.Success = success
	}
	return nil
}
func newAskUploadFileRollbackArgs() interface{} {
	return &AskUploadFileRollbackArgs{}
}

func newAskUploadFileRollbackResult() interface{} {
	return &AskUploadFileRollbackResult{}
}

type AskUploadFileRollbackArgs struct {
	Req *content.AskUploadFileReq
}

func (p *AskUploadFileRollbackArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.AskUploadFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AskUploadFileRollbackArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AskUploadFileRollbackArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AskUploadFileRollbackArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AskUploadFileRollbackArgs) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AskUploadFileRollbackArgs_Req_DEFAULT *content.AskUploadFileReq

func (p *AskUploadFileRollbackArgs) GetReq() *content.AskUploadFileReq {
	if !p.IsSetReq() {
		return AskUploadFileRollbackArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AskUploadFileRollbackArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AskUploadFileRollbackArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AskUploadFileRollbackResult struct {
	Success *content.AskUploadFileResp
}

var AskUploadFileRollbackResult_Success_DEFAULT *content.AskUploadFileResp

func (p *AskUploadFileRollbackResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.AskUploadFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AskUploadFileRollbackResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AskUploadFileRollbackResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AskUploadFileRollbackResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AskUploadFileRollbackResult) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AskUploadFileRollbackResult) GetSuccess() *content.AskUploadFileResp {
	if !p.IsSetSuccess() {
		return AskUploadFileRollbackResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AskUploadFileRollbackResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.AskUploadFileResp)
}

func (p *AskUploadFileRollbackResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AskUploadFileRollbackResult) GetResult() interface{} {
	return p.Success
}

func deleteExpiredFilesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteExpiredFilesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteExpiredFiles(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteExpiredFilesArgs:
		success, err := handler.(content.ContentService).DeleteExpiredFiles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteExpiredFilesResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteExpiredFilesArgs() interface{} {
	return &DeleteExpiredFilesArgs{}
}

func newDeleteExpiredFilesResult() interface{} {
	return &DeleteExpiredFilesResult{}
}

type DeleteExpiredFilesArgs struct {
	Req *content.DeleteExpiredFilesReq
}

func (p *DeleteExpiredFilesArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteExpiredFilesReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteExpiredFilesArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteExpiredFilesArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteExpiredFilesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteExpiredFilesArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredFilesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteExpiredFilesArgs_Req_DEFAULT *content.DeleteExpiredFilesReq

func (p *DeleteExpiredFilesArgs) GetReq() *content.DeleteExpiredFilesReq {
	if !p.IsSetReq() {
		return DeleteExpiredFilesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteExpiredFilesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteExpiredFilesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteExpiredFilesResult struct {
	Success *content.DeleteExpiredFilesResp
}

var DeleteExpiredFilesResult_Success_DEFAULT *content.DeleteExpiredFilesResp

func (p *DeleteExpiredFilesResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteExpiredFilesResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteExpiredFilesResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteExpiredFilesResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteExpiredFilesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteExpiredFilesResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredFilesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteExpiredFilesResult) GetSuccess() *content.DeleteExpiredFilesResp {
	if !p.IsSetSuccess() {
		return DeleteExpiredFilesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteExpiredFilesResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteExpiredFilesResp)
}

func (p *DeleteExpiredFilesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteExpiredFilesResult) GetResult() interface{} {
	return p.Success
}

func deleteExpiredShareCodesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteExpiredShareCodesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteExpiredShareCodes(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteExpiredShareCodesArgs:
		success, err := handler.(content.ContentService).DeleteExpiredShareCodes(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteExpiredShareCodesResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteExpiredShareCodesArgs() interface{} {
	return &DeleteExpiredShareCodesArgs{}
}

func newDeleteExpiredShareCodesResult() interface{} {
	return &DeleteExpiredShareCodesResult{}
}

type DeleteExpiredShareCodesArgs struct {
	Req *content.DeleteExpiredShareCodesReq
}

func (p *DeleteExpiredShareCodesArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteExpiredShareCodesReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteExpiredShareCodesArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteExpiredShareCodesArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteExpiredShareCodesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteExpiredShareCodesArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredShareCodesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteExpiredShareCodesArgs_Req_DEFAULT *content.DeleteExpiredShareCodesReq

func (p *DeleteExpiredShareCodesArgs) GetReq() *content.DeleteExpiredShareCodesReq {
	if !p.IsSetReq() {
		return DeleteExpiredShareCodesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteExpiredShareCodesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteExpiredShareCodesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteExpiredShareCodesResult struct {
	Success *content.DeleteExpiredShareCodesResp
}

var DeleteExpiredShareCodesResult_Success_DEFAULT *content.DeleteExpiredShareCodesResp

func (p *DeleteExpiredShareCodesResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteExpiredShareCodesResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteExpiredShareCodesResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteExpiredShareCodesResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteExpiredShareCodesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteExpiredShareCodesResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredShareCodesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteExpiredShareCodesResult) GetSuccess() *content.DeleteExpiredShareCodesResp {
	if !p.IsSetSuccess() {
		return DeleteExpiredShareCodesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteExpiredShareCodesResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteExpiredShareCodesResp)
}

func (p *DeleteExpiredShareCodesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteExpiredShareCodesResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) GetCosInfo(ctx context.Context, Req *content.GetCosInfoReq) (r *content.GetCosInfoResp, err error) {
	var _args GetCosInfoArgs
	_args.Req = Req
	var _result GetCosInfoResult
	if err = p.c.Call(ctx, "GetCosInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileByMd5(ctx context.Context, Req *content.GetFileByMd5Req) (r *content.GetFileByMd5Resp, err error) {
	var _args GetFileByMd5Args
	_args.Req = Req
	var _result GetFileByMd5Result
	if err = p.c.Call(ctx, "GetFileByMd5", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileInfoByFileId(ctx context.Context, Req *content.GetFileInfoByFileIdReq) (r *content.GetFileInfoByFileIdResp, err error) {
	var _args GetFileInfoByFileIdArgs
	_args.Req = Req
	var _result GetFileInfoByFileIdResult
	if err = p.c.Call(ctx, "GetFileInfoByFileId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileByFileIdWithUserId(ctx context.Context, Req *content.GetFileByFileIdWithUserIdReq) (r *content.GetFileByFileIdWithUserIdResp, err error) {
	var _args GetFileByFileIdWithUserIdArgs
	_args.Req = Req
	var _result GetFileByFileIdWithUserIdResult
	if err = p.c.Call(ctx, "GetFileByFileIdWithUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileInfoByFileIds(ctx context.Context, Req *content.GetFileInfoByFileIdsReq) (r *content.GetFileInfoByFileIdsResp, err error) {
	var _args GetFileInfoByFileIdsArgs
	_args.Req = Req
	var _result GetFileInfoByFileIdsResult
	if err = p.c.Call(ctx, "GetFileInfoByFileIds", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileInfoByFileIdsWithUserId(ctx context.Context, Req *content.GetFileInfoByFileIdsWithUserIdReq) (r *content.GetFileInfoByFileIdsWithUserIdResp, err error) {
	var _args GetFileInfoByFileIdsWithUserIdArgs
	_args.Req = Req
	var _result GetFileInfoByFileIdsWithUserIdResult
	if err = p.c.Call(ctx, "GetFileInfoByFileIdsWithUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFilesByFatherId(ctx context.Context, Req *content.GetFilesByFatherIdReq) (r *content.GetFilesByFatherIdResp, err error) {
	var _args GetFilesByFatherIdArgs
	_args.Req = Req
	var _result GetFilesByFatherIdResult
	if err = p.c.Call(ctx, "GetFilesByFatherId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFilesByFatherIdWithUserId(ctx context.Context, Req *content.GetFilesByFatherIdWithUserIdReq) (r *content.GetFilesByFatherIdWithUserIdResp, err error) {
	var _args GetFilesByFatherIdWithUserIdArgs
	_args.Req = Req
	var _result GetFilesByFatherIdWithUserIdResult
	if err = p.c.Call(ctx, "GetFilesByFatherIdWithUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetAllFileByFatherId(ctx context.Context, Req *content.GetAllFileByFatherIdReq) (r *content.GetAllFileByFatherIdResp, err error) {
	var _args GetAllFileByFatherIdArgs
	_args.Req = Req
	var _result GetAllFileByFatherIdResult
	if err = p.c.Call(ctx, "GetAllFileByFatherId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileCount(ctx context.Context, Req *content.GetFileCountReq) (r *content.GetFileCountResp, err error) {
	var _args GetFileCountArgs
	_args.Req = Req
	var _result GetFileCountResult
	if err = p.c.Call(ctx, "GetFileCount", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileType(ctx context.Context, Req *content.GetFileTypeReq) (r *content.GetFileTypeReq, err error) {
	var _args GetFileTypeArgs
	_args.Req = Req
	var _result GetFileTypeResult
	if err = p.c.Call(ctx, "GetFileType", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileInfoInPublicByFileId(ctx context.Context, Req *content.GetFileInfoInPublicByFileIdReq) (r *content.GetFileInfoInPublicByFileIdResp, err error) {
	var _args GetFileInfoInPublicByFileIdArgs
	_args.Req = Req
	var _result GetFileInfoInPublicByFileIdResult
	if err = p.c.Call(ctx, "GetFileInfoInPublicByFileId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPublicFileByFileIdWithUserId(ctx context.Context, Req *content.GetPublicFileByFileIdWithUserIdReq) (r *content.GetPublicFileByFileIdWithUserIdResp, err error) {
	var _args GetPublicFileByFileIdWithUserIdArgs
	_args.Req = Req
	var _result GetPublicFileByFileIdWithUserIdResult
	if err = p.c.Call(ctx, "GetPublicFileByFileIdWithUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPublicByFileIds(ctx context.Context, Req *content.GetPublicByFileIdsReq) (r *content.GetPublicByFileIdsResp, err error) {
	var _args GetPublicByFileIdsArgs
	_args.Req = Req
	var _result GetPublicByFileIdsResult
	if err = p.c.Call(ctx, "GetPublicByFileIds", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPublicFilesByUserId(ctx context.Context, Req *content.GetPublicFilesByUserIdReq) (r *content.GetPublicFilesByUserIdResp, err error) {
	var _args GetPublicFilesByUserIdArgs
	_args.Req = Req
	var _result GetPublicFilesByUserIdResult
	if err = p.c.Call(ctx, "GetPublicFilesByUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPublicFilesByFatherId(ctx context.Context, Req *content.GetPublicFilesByFatherIdReq) (r *content.GetPublicFilesByFatherIdResp, err error) {
	var _args GetPublicFilesByFatherIdArgs
	_args.Req = Req
	var _result GetPublicFilesByFatherIdResult
	if err = p.c.Call(ctx, "GetPublicFilesByFatherId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetAllPublicFileByFatherId(ctx context.Context, Req *content.GetAllPublicFileByFatherIdReq) (r *content.GetAllPublicFileByFatherIdResp, err error) {
	var _args GetAllPublicFileByFatherIdArgs
	_args.Req = Req
	var _result GetAllPublicFileByFatherIdResult
	if err = p.c.Call(ctx, "GetAllPublicFileByFatherId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileBySharingCode(ctx context.Context, Req *content.GetFileBySharingCodeReq) (r *content.GetFileBySharingCodeResp, err error) {
	var _args GetFileBySharingCodeArgs
	_args.Req = Req
	var _result GetFileBySharingCodeResult
	if err = p.c.Call(ctx, "GetFileBySharingCode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CalFileSize(ctx context.Context, Req *content.CalFileSizeReq) (r *content.CalFileSizeResp, err error) {
	var _args CalFileSizeArgs
	_args.Req = Req
	var _result CalFileSizeResult
	if err = p.c.Call(ctx, "CalFileSize", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CalPublicFileSize(ctx context.Context, Req *content.CalPublicFileSizeReq) (r *content.CalPublicFileSizeResp, err error) {
	var _args CalPublicFileSizeArgs
	_args.Req = Req
	var _result CalPublicFileSizeResult
	if err = p.c.Call(ctx, "CalPublicFileSize", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UploadFile(ctx context.Context, Req *content.UploadFileReq) (r *content.UploadFileResp, err error) {
	var _args UploadFileArgs
	_args.Req = Req
	var _result UploadFileResult
	if err = p.c.Call(ctx, "UploadFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AskUploadFile(ctx context.Context, Req *content.AskUploadFileReq) (r *content.AskUploadFileResp, err error) {
	var _args AskUploadFileArgs
	_args.Req = Req
	var _result AskUploadFileResult
	if err = p.c.Call(ctx, "AskUploadFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AskUploadFileRollback(ctx context.Context, Req *content.AskUploadFileReq) (r *content.AskUploadFileResp, err error) {
	var _args AskUploadFileRollbackArgs
	_args.Req = Req
	var _result AskUploadFileRollbackResult
	if err = p.c.Call(ctx, "AskUploadFileRollback", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteExpiredFiles(ctx context.Context, Req *content.DeleteExpiredFilesReq) (r *content.DeleteExpiredFilesResp, err error) {
	var _args DeleteExpiredFilesArgs
	_args.Req = Req
	var _result DeleteExpiredFilesResult
	if err = p.c.Call(ctx, "DeleteExpiredFiles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteExpiredShareCodes(ctx context.Context, Req *content.DeleteExpiredShareCodesReq) (r *content.DeleteExpiredShareCodesResp, err error) {
	var _args DeleteExpiredShareCodesArgs
	_args.Req = Req
	var _result DeleteExpiredShareCodesResult
	if err = p.c.Call(ctx, "DeleteExpiredShareCodes", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
