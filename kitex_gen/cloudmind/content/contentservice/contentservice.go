// Code generated by Kitex v0.8.0. DO NOT EDIT.

package contentservice

import (
	"context"
	content "github.com/CloudStriver/service-idl-gen-go/kitex_gen/cloudmind/content"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return contentServiceServiceInfo
}

var contentServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "ContentService"
	handlerType := (*content.ContentService)(nil)
	methods := map[string]kitex.MethodInfo{
		"GetFileIsExist":          kitex.NewMethodInfo(getFileIsExistHandler, newGetFileIsExistArgs, newGetFileIsExistResult, false),
		"GetFile":                 kitex.NewMethodInfo(getFileHandler, newGetFileArgs, newGetFileResult, false),
		"GetFileList":             kitex.NewMethodInfo(getFileListHandler, newGetFileListArgs, newGetFileListResult, false),
		"GetFileCount":            kitex.NewMethodInfo(getFileCountHandler, newGetFileCountArgs, newGetFileCountResult, false),
		"GetFileBySharingCode":    kitex.NewMethodInfo(getFileBySharingCodeHandler, newGetFileBySharingCodeArgs, newGetFileBySharingCodeResult, false),
		"GetFolderSize":           kitex.NewMethodInfo(getFolderSizeHandler, newGetFolderSizeArgs, newGetFolderSizeResult, false),
		"CreateFolder":            kitex.NewMethodInfo(createFolderHandler, newCreateFolderArgs, newCreateFolderResult, false),
		"UpdateFile":              kitex.NewMethodInfo(updateFileHandler, newUpdateFileArgs, newUpdateFileResult, false),
		"MoveFile":                kitex.NewMethodInfo(moveFileHandler, newMoveFileArgs, newMoveFileResult, false),
		"AskUploadFile":           kitex.NewMethodInfo(askUploadFileHandler, newAskUploadFileArgs, newAskUploadFileResult, false),
		"AskUploadFileRollback":   kitex.NewMethodInfo(askUploadFileRollbackHandler, newAskUploadFileRollbackArgs, newAskUploadFileRollbackResult, false),
		"DeleteFile":              kitex.NewMethodInfo(deleteFileHandler, newDeleteFileArgs, newDeleteFileResult, false),
		"DeleteShareFile":         kitex.NewMethodInfo(deleteShareFileHandler, newDeleteShareFileArgs, newDeleteShareFileResult, false),
		"DeleteExpiredFiles":      kitex.NewMethodInfo(deleteExpiredFilesHandler, newDeleteExpiredFilesArgs, newDeleteExpiredFilesResult, false),
		"DeleteExpiredShareCodes": kitex.NewMethodInfo(deleteExpiredShareCodesHandler, newDeleteExpiredShareCodesArgs, newDeleteExpiredShareCodesResult, false),
		"GetLabel":                kitex.NewMethodInfo(getLabelHandler, newGetLabelArgs, newGetLabelResult, false),
		"CreateLabel":             kitex.NewMethodInfo(createLabelHandler, newCreateLabelArgs, newCreateLabelResult, false),
		"UpdateLabel":             kitex.NewMethodInfo(updateLabelHandler, newUpdateLabelArgs, newUpdateLabelResult, false),
		"DeleteLabel":             kitex.NewMethodInfo(deleteLabelHandler, newDeleteLabelArgs, newDeleteLabelResult, false),
	}
	extra := map[string]interface{}{
		"PackageName":     "cloudmind.content",
		"ServiceFilePath": ``,
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.8.0",
		Extra:           extra,
	}
	return svcInfo
}

func getFileIsExistHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileIsExistReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileIsExist(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileIsExistArgs:
		success, err := handler.(content.ContentService).GetFileIsExist(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileIsExistResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileIsExistArgs() interface{} {
	return &GetFileIsExistArgs{}
}

func newGetFileIsExistResult() interface{} {
	return &GetFileIsExistResult{}
}

type GetFileIsExistArgs struct {
	Req *content.GetFileIsExistReq
}

func (p *GetFileIsExistArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileIsExistReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileIsExistArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileIsExistArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileIsExistArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileIsExistArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileIsExistReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileIsExistArgs_Req_DEFAULT *content.GetFileIsExistReq

func (p *GetFileIsExistArgs) GetReq() *content.GetFileIsExistReq {
	if !p.IsSetReq() {
		return GetFileIsExistArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileIsExistArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileIsExistArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileIsExistResult struct {
	Success *content.GetFileIsExistResp
}

var GetFileIsExistResult_Success_DEFAULT *content.GetFileIsExistResp

func (p *GetFileIsExistResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileIsExistResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileIsExistResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileIsExistResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileIsExistResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileIsExistResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileIsExistResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileIsExistResult) GetSuccess() *content.GetFileIsExistResp {
	if !p.IsSetSuccess() {
		return GetFileIsExistResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileIsExistResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileIsExistResp)
}

func (p *GetFileIsExistResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileIsExistResult) GetResult() interface{} {
	return p.Success
}

func getFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileArgs:
		success, err := handler.(content.ContentService).GetFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileArgs() interface{} {
	return &GetFileArgs{}
}

func newGetFileResult() interface{} {
	return &GetFileResult{}
}

type GetFileArgs struct {
	Req *content.GetFileReq
}

func (p *GetFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileArgs_Req_DEFAULT *content.GetFileReq

func (p *GetFileArgs) GetReq() *content.GetFileReq {
	if !p.IsSetReq() {
		return GetFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileResult struct {
	Success *content.GetFileResp
}

var GetFileResult_Success_DEFAULT *content.GetFileResp

func (p *GetFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileResult) GetSuccess() *content.GetFileResp {
	if !p.IsSetSuccess() {
		return GetFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileResp)
}

func (p *GetFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileResult) GetResult() interface{} {
	return p.Success
}

func getFileListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileListReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileList(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileListArgs:
		success, err := handler.(content.ContentService).GetFileList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileListResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileListArgs() interface{} {
	return &GetFileListArgs{}
}

func newGetFileListResult() interface{} {
	return &GetFileListResult{}
}

type GetFileListArgs struct {
	Req *content.GetFileListReq
}

func (p *GetFileListArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileListReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileListArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileListArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileListArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileListReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileListArgs_Req_DEFAULT *content.GetFileListReq

func (p *GetFileListArgs) GetReq() *content.GetFileListReq {
	if !p.IsSetReq() {
		return GetFileListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileListResult struct {
	Success *content.GetFileListResp
}

var GetFileListResult_Success_DEFAULT *content.GetFileListResp

func (p *GetFileListResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileListResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileListResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileListResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileListResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileListResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileListResult) GetSuccess() *content.GetFileListResp {
	if !p.IsSetSuccess() {
		return GetFileListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileListResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileListResp)
}

func (p *GetFileListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileListResult) GetResult() interface{} {
	return p.Success
}

func getFileCountHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileCountReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileCount(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileCountArgs:
		success, err := handler.(content.ContentService).GetFileCount(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileCountResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileCountArgs() interface{} {
	return &GetFileCountArgs{}
}

func newGetFileCountResult() interface{} {
	return &GetFileCountResult{}
}

type GetFileCountArgs struct {
	Req *content.GetFileCountReq
}

func (p *GetFileCountArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileCountReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileCountArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileCountArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileCountArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileCountArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileCountReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileCountArgs_Req_DEFAULT *content.GetFileCountReq

func (p *GetFileCountArgs) GetReq() *content.GetFileCountReq {
	if !p.IsSetReq() {
		return GetFileCountArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileCountArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileCountArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileCountResult struct {
	Success *content.GetFileCountResp
}

var GetFileCountResult_Success_DEFAULT *content.GetFileCountResp

func (p *GetFileCountResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileCountResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileCountResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileCountResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileCountResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileCountResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileCountResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileCountResult) GetSuccess() *content.GetFileCountResp {
	if !p.IsSetSuccess() {
		return GetFileCountResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileCountResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileCountResp)
}

func (p *GetFileCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileCountResult) GetResult() interface{} {
	return p.Success
}

func getFileBySharingCodeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFileBySharingCodeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFileBySharingCode(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFileBySharingCodeArgs:
		success, err := handler.(content.ContentService).GetFileBySharingCode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileBySharingCodeResult)
		realResult.Success = success
	}
	return nil
}
func newGetFileBySharingCodeArgs() interface{} {
	return &GetFileBySharingCodeArgs{}
}

func newGetFileBySharingCodeResult() interface{} {
	return &GetFileBySharingCodeResult{}
}

type GetFileBySharingCodeArgs struct {
	Req *content.GetFileBySharingCodeReq
}

func (p *GetFileBySharingCodeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFileBySharingCodeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFileBySharingCodeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFileBySharingCodeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFileBySharingCodeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileBySharingCodeArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFileBySharingCodeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileBySharingCodeArgs_Req_DEFAULT *content.GetFileBySharingCodeReq

func (p *GetFileBySharingCodeArgs) GetReq() *content.GetFileBySharingCodeReq {
	if !p.IsSetReq() {
		return GetFileBySharingCodeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileBySharingCodeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileBySharingCodeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileBySharingCodeResult struct {
	Success *content.GetFileBySharingCodeResp
}

var GetFileBySharingCodeResult_Success_DEFAULT *content.GetFileBySharingCodeResp

func (p *GetFileBySharingCodeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFileBySharingCodeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFileBySharingCodeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFileBySharingCodeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFileBySharingCodeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileBySharingCodeResult) Unmarshal(in []byte) error {
	msg := new(content.GetFileBySharingCodeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileBySharingCodeResult) GetSuccess() *content.GetFileBySharingCodeResp {
	if !p.IsSetSuccess() {
		return GetFileBySharingCodeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileBySharingCodeResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFileBySharingCodeResp)
}

func (p *GetFileBySharingCodeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileBySharingCodeResult) GetResult() interface{} {
	return p.Success
}

func getFolderSizeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetFolderSizeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetFolderSize(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFolderSizeArgs:
		success, err := handler.(content.ContentService).GetFolderSize(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFolderSizeResult)
		realResult.Success = success
	}
	return nil
}
func newGetFolderSizeArgs() interface{} {
	return &GetFolderSizeArgs{}
}

func newGetFolderSizeResult() interface{} {
	return &GetFolderSizeResult{}
}

type GetFolderSizeArgs struct {
	Req *content.GetFolderSizeReq
}

func (p *GetFolderSizeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetFolderSizeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFolderSizeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFolderSizeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFolderSizeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFolderSizeArgs) Unmarshal(in []byte) error {
	msg := new(content.GetFolderSizeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFolderSizeArgs_Req_DEFAULT *content.GetFolderSizeReq

func (p *GetFolderSizeArgs) GetReq() *content.GetFolderSizeReq {
	if !p.IsSetReq() {
		return GetFolderSizeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFolderSizeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFolderSizeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFolderSizeResult struct {
	Success *content.GetFolderSizeResp
}

var GetFolderSizeResult_Success_DEFAULT *content.GetFolderSizeResp

func (p *GetFolderSizeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetFolderSizeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFolderSizeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFolderSizeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFolderSizeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFolderSizeResult) Unmarshal(in []byte) error {
	msg := new(content.GetFolderSizeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFolderSizeResult) GetSuccess() *content.GetFolderSizeResp {
	if !p.IsSetSuccess() {
		return GetFolderSizeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFolderSizeResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetFolderSizeResp)
}

func (p *GetFolderSizeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFolderSizeResult) GetResult() interface{} {
	return p.Success
}

func createFolderHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CreateFolderReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CreateFolder(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateFolderArgs:
		success, err := handler.(content.ContentService).CreateFolder(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateFolderResult)
		realResult.Success = success
	}
	return nil
}
func newCreateFolderArgs() interface{} {
	return &CreateFolderArgs{}
}

func newCreateFolderResult() interface{} {
	return &CreateFolderResult{}
}

type CreateFolderArgs struct {
	Req *content.CreateFolderReq
}

func (p *CreateFolderArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CreateFolderReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateFolderArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateFolderArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateFolderArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateFolderArgs) Unmarshal(in []byte) error {
	msg := new(content.CreateFolderReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateFolderArgs_Req_DEFAULT *content.CreateFolderReq

func (p *CreateFolderArgs) GetReq() *content.CreateFolderReq {
	if !p.IsSetReq() {
		return CreateFolderArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateFolderArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateFolderArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateFolderResult struct {
	Success *content.CreateFolderResp
}

var CreateFolderResult_Success_DEFAULT *content.CreateFolderResp

func (p *CreateFolderResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CreateFolderResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateFolderResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateFolderResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateFolderResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateFolderResult) Unmarshal(in []byte) error {
	msg := new(content.CreateFolderResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateFolderResult) GetSuccess() *content.CreateFolderResp {
	if !p.IsSetSuccess() {
		return CreateFolderResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateFolderResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CreateFolderResp)
}

func (p *CreateFolderResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateFolderResult) GetResult() interface{} {
	return p.Success
}

func updateFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.UpdateFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).UpdateFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateFileArgs:
		success, err := handler.(content.ContentService).UpdateFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateFileResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateFileArgs() interface{} {
	return &UpdateFileArgs{}
}

func newUpdateFileResult() interface{} {
	return &UpdateFileResult{}
}

type UpdateFileArgs struct {
	Req *content.UpdateFileReq
}

func (p *UpdateFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.UpdateFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateFileArgs) Unmarshal(in []byte) error {
	msg := new(content.UpdateFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateFileArgs_Req_DEFAULT *content.UpdateFileReq

func (p *UpdateFileArgs) GetReq() *content.UpdateFileReq {
	if !p.IsSetReq() {
		return UpdateFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateFileResult struct {
	Success *content.UpdateFileResp
}

var UpdateFileResult_Success_DEFAULT *content.UpdateFileResp

func (p *UpdateFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.UpdateFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateFileResult) Unmarshal(in []byte) error {
	msg := new(content.UpdateFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateFileResult) GetSuccess() *content.UpdateFileResp {
	if !p.IsSetSuccess() {
		return UpdateFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.UpdateFileResp)
}

func (p *UpdateFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateFileResult) GetResult() interface{} {
	return p.Success
}

func moveFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.MoveFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).MoveFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MoveFileArgs:
		success, err := handler.(content.ContentService).MoveFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MoveFileResult)
		realResult.Success = success
	}
	return nil
}
func newMoveFileArgs() interface{} {
	return &MoveFileArgs{}
}

func newMoveFileResult() interface{} {
	return &MoveFileResult{}
}

type MoveFileArgs struct {
	Req *content.MoveFileReq
}

func (p *MoveFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.MoveFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *MoveFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *MoveFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *MoveFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *MoveFileArgs) Unmarshal(in []byte) error {
	msg := new(content.MoveFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MoveFileArgs_Req_DEFAULT *content.MoveFileReq

func (p *MoveFileArgs) GetReq() *content.MoveFileReq {
	if !p.IsSetReq() {
		return MoveFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MoveFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *MoveFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type MoveFileResult struct {
	Success *content.MoveFileResp
}

var MoveFileResult_Success_DEFAULT *content.MoveFileResp

func (p *MoveFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.MoveFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *MoveFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *MoveFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *MoveFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *MoveFileResult) Unmarshal(in []byte) error {
	msg := new(content.MoveFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MoveFileResult) GetSuccess() *content.MoveFileResp {
	if !p.IsSetSuccess() {
		return MoveFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MoveFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.MoveFileResp)
}

func (p *MoveFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MoveFileResult) GetResult() interface{} {
	return p.Success
}

func askUploadFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.AskUploadFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).AskUploadFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AskUploadFileArgs:
		success, err := handler.(content.ContentService).AskUploadFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AskUploadFileResult)
		realResult.Success = success
	}
	return nil
}
func newAskUploadFileArgs() interface{} {
	return &AskUploadFileArgs{}
}

func newAskUploadFileResult() interface{} {
	return &AskUploadFileResult{}
}

type AskUploadFileArgs struct {
	Req *content.AskUploadFileReq
}

func (p *AskUploadFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.AskUploadFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AskUploadFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AskUploadFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AskUploadFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AskUploadFileArgs) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AskUploadFileArgs_Req_DEFAULT *content.AskUploadFileReq

func (p *AskUploadFileArgs) GetReq() *content.AskUploadFileReq {
	if !p.IsSetReq() {
		return AskUploadFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AskUploadFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AskUploadFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AskUploadFileResult struct {
	Success *content.AskUploadFileResp
}

var AskUploadFileResult_Success_DEFAULT *content.AskUploadFileResp

func (p *AskUploadFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.AskUploadFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AskUploadFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AskUploadFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AskUploadFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AskUploadFileResult) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AskUploadFileResult) GetSuccess() *content.AskUploadFileResp {
	if !p.IsSetSuccess() {
		return AskUploadFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AskUploadFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.AskUploadFileResp)
}

func (p *AskUploadFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AskUploadFileResult) GetResult() interface{} {
	return p.Success
}

func askUploadFileRollbackHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.AskUploadFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).AskUploadFileRollback(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AskUploadFileRollbackArgs:
		success, err := handler.(content.ContentService).AskUploadFileRollback(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AskUploadFileRollbackResult)
		realResult.Success = success
	}
	return nil
}
func newAskUploadFileRollbackArgs() interface{} {
	return &AskUploadFileRollbackArgs{}
}

func newAskUploadFileRollbackResult() interface{} {
	return &AskUploadFileRollbackResult{}
}

type AskUploadFileRollbackArgs struct {
	Req *content.AskUploadFileReq
}

func (p *AskUploadFileRollbackArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.AskUploadFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AskUploadFileRollbackArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AskUploadFileRollbackArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AskUploadFileRollbackArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AskUploadFileRollbackArgs) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AskUploadFileRollbackArgs_Req_DEFAULT *content.AskUploadFileReq

func (p *AskUploadFileRollbackArgs) GetReq() *content.AskUploadFileReq {
	if !p.IsSetReq() {
		return AskUploadFileRollbackArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AskUploadFileRollbackArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AskUploadFileRollbackArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AskUploadFileRollbackResult struct {
	Success *content.AskUploadFileResp
}

var AskUploadFileRollbackResult_Success_DEFAULT *content.AskUploadFileResp

func (p *AskUploadFileRollbackResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.AskUploadFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AskUploadFileRollbackResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AskUploadFileRollbackResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AskUploadFileRollbackResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AskUploadFileRollbackResult) Unmarshal(in []byte) error {
	msg := new(content.AskUploadFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AskUploadFileRollbackResult) GetSuccess() *content.AskUploadFileResp {
	if !p.IsSetSuccess() {
		return AskUploadFileRollbackResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AskUploadFileRollbackResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.AskUploadFileResp)
}

func (p *AskUploadFileRollbackResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AskUploadFileRollbackResult) GetResult() interface{} {
	return p.Success
}

func deleteFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteFileArgs:
		success, err := handler.(content.ContentService).DeleteFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteFileResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteFileArgs() interface{} {
	return &DeleteFileArgs{}
}

func newDeleteFileResult() interface{} {
	return &DeleteFileResult{}
}

type DeleteFileArgs struct {
	Req *content.DeleteFileReq
}

func (p *DeleteFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteFileArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteFileArgs_Req_DEFAULT *content.DeleteFileReq

func (p *DeleteFileArgs) GetReq() *content.DeleteFileReq {
	if !p.IsSetReq() {
		return DeleteFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteFileResult struct {
	Success *content.DeleteFileResp
}

var DeleteFileResult_Success_DEFAULT *content.DeleteFileResp

func (p *DeleteFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteFileResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteFileResult) GetSuccess() *content.DeleteFileResp {
	if !p.IsSetSuccess() {
		return DeleteFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteFileResp)
}

func (p *DeleteFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteFileResult) GetResult() interface{} {
	return p.Success
}

func deleteShareFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteShareFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteShareFile(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteShareFileArgs:
		success, err := handler.(content.ContentService).DeleteShareFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteShareFileResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteShareFileArgs() interface{} {
	return &DeleteShareFileArgs{}
}

func newDeleteShareFileResult() interface{} {
	return &DeleteShareFileResult{}
}

type DeleteShareFileArgs struct {
	Req *content.DeleteShareFileReq
}

func (p *DeleteShareFileArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteShareFileReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteShareFileArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteShareFileArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteShareFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteShareFileArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteShareFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteShareFileArgs_Req_DEFAULT *content.DeleteShareFileReq

func (p *DeleteShareFileArgs) GetReq() *content.DeleteShareFileReq {
	if !p.IsSetReq() {
		return DeleteShareFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteShareFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteShareFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteShareFileResult struct {
	Success *content.DeleteShareFileResp
}

var DeleteShareFileResult_Success_DEFAULT *content.DeleteShareFileResp

func (p *DeleteShareFileResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteShareFileResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteShareFileResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteShareFileResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteShareFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteShareFileResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteShareFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteShareFileResult) GetSuccess() *content.DeleteShareFileResp {
	if !p.IsSetSuccess() {
		return DeleteShareFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteShareFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteShareFileResp)
}

func (p *DeleteShareFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteShareFileResult) GetResult() interface{} {
	return p.Success
}

func deleteExpiredFilesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteExpiredFilesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteExpiredFiles(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteExpiredFilesArgs:
		success, err := handler.(content.ContentService).DeleteExpiredFiles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteExpiredFilesResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteExpiredFilesArgs() interface{} {
	return &DeleteExpiredFilesArgs{}
}

func newDeleteExpiredFilesResult() interface{} {
	return &DeleteExpiredFilesResult{}
}

type DeleteExpiredFilesArgs struct {
	Req *content.DeleteExpiredFilesReq
}

func (p *DeleteExpiredFilesArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteExpiredFilesReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteExpiredFilesArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteExpiredFilesArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteExpiredFilesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteExpiredFilesArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredFilesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteExpiredFilesArgs_Req_DEFAULT *content.DeleteExpiredFilesReq

func (p *DeleteExpiredFilesArgs) GetReq() *content.DeleteExpiredFilesReq {
	if !p.IsSetReq() {
		return DeleteExpiredFilesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteExpiredFilesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteExpiredFilesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteExpiredFilesResult struct {
	Success *content.DeleteExpiredFilesResp
}

var DeleteExpiredFilesResult_Success_DEFAULT *content.DeleteExpiredFilesResp

func (p *DeleteExpiredFilesResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteExpiredFilesResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteExpiredFilesResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteExpiredFilesResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteExpiredFilesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteExpiredFilesResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredFilesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteExpiredFilesResult) GetSuccess() *content.DeleteExpiredFilesResp {
	if !p.IsSetSuccess() {
		return DeleteExpiredFilesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteExpiredFilesResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteExpiredFilesResp)
}

func (p *DeleteExpiredFilesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteExpiredFilesResult) GetResult() interface{} {
	return p.Success
}

func deleteExpiredShareCodesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteExpiredShareCodesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteExpiredShareCodes(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteExpiredShareCodesArgs:
		success, err := handler.(content.ContentService).DeleteExpiredShareCodes(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteExpiredShareCodesResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteExpiredShareCodesArgs() interface{} {
	return &DeleteExpiredShareCodesArgs{}
}

func newDeleteExpiredShareCodesResult() interface{} {
	return &DeleteExpiredShareCodesResult{}
}

type DeleteExpiredShareCodesArgs struct {
	Req *content.DeleteExpiredShareCodesReq
}

func (p *DeleteExpiredShareCodesArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteExpiredShareCodesReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteExpiredShareCodesArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteExpiredShareCodesArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteExpiredShareCodesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteExpiredShareCodesArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredShareCodesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteExpiredShareCodesArgs_Req_DEFAULT *content.DeleteExpiredShareCodesReq

func (p *DeleteExpiredShareCodesArgs) GetReq() *content.DeleteExpiredShareCodesReq {
	if !p.IsSetReq() {
		return DeleteExpiredShareCodesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteExpiredShareCodesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteExpiredShareCodesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteExpiredShareCodesResult struct {
	Success *content.DeleteExpiredShareCodesResp
}

var DeleteExpiredShareCodesResult_Success_DEFAULT *content.DeleteExpiredShareCodesResp

func (p *DeleteExpiredShareCodesResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteExpiredShareCodesResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteExpiredShareCodesResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteExpiredShareCodesResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteExpiredShareCodesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteExpiredShareCodesResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteExpiredShareCodesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteExpiredShareCodesResult) GetSuccess() *content.DeleteExpiredShareCodesResp {
	if !p.IsSetSuccess() {
		return DeleteExpiredShareCodesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteExpiredShareCodesResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteExpiredShareCodesResp)
}

func (p *DeleteExpiredShareCodesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteExpiredShareCodesResult) GetResult() interface{} {
	return p.Success
}

func getLabelHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.GetLabelReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).GetLabel(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetLabelArgs:
		success, err := handler.(content.ContentService).GetLabel(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetLabelResult)
		realResult.Success = success
	}
	return nil
}
func newGetLabelArgs() interface{} {
	return &GetLabelArgs{}
}

func newGetLabelResult() interface{} {
	return &GetLabelResult{}
}

type GetLabelArgs struct {
	Req *content.GetLabelReq
}

func (p *GetLabelArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.GetLabelReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetLabelArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetLabelArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetLabelArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetLabelArgs) Unmarshal(in []byte) error {
	msg := new(content.GetLabelReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetLabelArgs_Req_DEFAULT *content.GetLabelReq

func (p *GetLabelArgs) GetReq() *content.GetLabelReq {
	if !p.IsSetReq() {
		return GetLabelArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetLabelArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetLabelArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetLabelResult struct {
	Success *content.GetLabelResp
}

var GetLabelResult_Success_DEFAULT *content.GetLabelResp

func (p *GetLabelResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.GetLabelResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetLabelResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetLabelResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetLabelResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetLabelResult) Unmarshal(in []byte) error {
	msg := new(content.GetLabelResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetLabelResult) GetSuccess() *content.GetLabelResp {
	if !p.IsSetSuccess() {
		return GetLabelResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetLabelResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.GetLabelResp)
}

func (p *GetLabelResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetLabelResult) GetResult() interface{} {
	return p.Success
}

func createLabelHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CreateLabelReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CreateLabel(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateLabelArgs:
		success, err := handler.(content.ContentService).CreateLabel(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateLabelResult)
		realResult.Success = success
	}
	return nil
}
func newCreateLabelArgs() interface{} {
	return &CreateLabelArgs{}
}

func newCreateLabelResult() interface{} {
	return &CreateLabelResult{}
}

type CreateLabelArgs struct {
	Req *content.CreateLabelReq
}

func (p *CreateLabelArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CreateLabelReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateLabelArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateLabelArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateLabelArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateLabelArgs) Unmarshal(in []byte) error {
	msg := new(content.CreateLabelReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateLabelArgs_Req_DEFAULT *content.CreateLabelReq

func (p *CreateLabelArgs) GetReq() *content.CreateLabelReq {
	if !p.IsSetReq() {
		return CreateLabelArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateLabelArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateLabelArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateLabelResult struct {
	Success *content.CreateLabelResp
}

var CreateLabelResult_Success_DEFAULT *content.CreateLabelResp

func (p *CreateLabelResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CreateLabelResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateLabelResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateLabelResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateLabelResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateLabelResult) Unmarshal(in []byte) error {
	msg := new(content.CreateLabelResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateLabelResult) GetSuccess() *content.CreateLabelResp {
	if !p.IsSetSuccess() {
		return CreateLabelResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateLabelResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CreateLabelResp)
}

func (p *CreateLabelResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateLabelResult) GetResult() interface{} {
	return p.Success
}

func updateLabelHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.UpdateLabelReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).UpdateLabel(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateLabelArgs:
		success, err := handler.(content.ContentService).UpdateLabel(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateLabelResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateLabelArgs() interface{} {
	return &UpdateLabelArgs{}
}

func newUpdateLabelResult() interface{} {
	return &UpdateLabelResult{}
}

type UpdateLabelArgs struct {
	Req *content.UpdateLabelReq
}

func (p *UpdateLabelArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.UpdateLabelReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateLabelArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateLabelArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateLabelArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateLabelArgs) Unmarshal(in []byte) error {
	msg := new(content.UpdateLabelReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateLabelArgs_Req_DEFAULT *content.UpdateLabelReq

func (p *UpdateLabelArgs) GetReq() *content.UpdateLabelReq {
	if !p.IsSetReq() {
		return UpdateLabelArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateLabelArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateLabelArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateLabelResult struct {
	Success *content.UpdateLabelResp
}

var UpdateLabelResult_Success_DEFAULT *content.UpdateLabelResp

func (p *UpdateLabelResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.UpdateLabelResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateLabelResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateLabelResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateLabelResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateLabelResult) Unmarshal(in []byte) error {
	msg := new(content.UpdateLabelResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateLabelResult) GetSuccess() *content.UpdateLabelResp {
	if !p.IsSetSuccess() {
		return UpdateLabelResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateLabelResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.UpdateLabelResp)
}

func (p *UpdateLabelResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateLabelResult) GetResult() interface{} {
	return p.Success
}

func deleteLabelHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteLabelReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteLabel(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteLabelArgs:
		success, err := handler.(content.ContentService).DeleteLabel(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteLabelResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteLabelArgs() interface{} {
	return &DeleteLabelArgs{}
}

func newDeleteLabelResult() interface{} {
	return &DeleteLabelResult{}
}

type DeleteLabelArgs struct {
	Req *content.DeleteLabelReq
}

func (p *DeleteLabelArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteLabelReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteLabelArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteLabelArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteLabelArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteLabelArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteLabelReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteLabelArgs_Req_DEFAULT *content.DeleteLabelReq

func (p *DeleteLabelArgs) GetReq() *content.DeleteLabelReq {
	if !p.IsSetReq() {
		return DeleteLabelArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteLabelArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteLabelArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteLabelResult struct {
	Success *content.DeleteLabelResp
}

var DeleteLabelResult_Success_DEFAULT *content.DeleteLabelResp

func (p *DeleteLabelResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteLabelResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteLabelResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteLabelResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteLabelResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteLabelResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteLabelResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteLabelResult) GetSuccess() *content.DeleteLabelResp {
	if !p.IsSetSuccess() {
		return DeleteLabelResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteLabelResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteLabelResp)
}

func (p *DeleteLabelResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteLabelResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) GetFileIsExist(ctx context.Context, Req *content.GetFileIsExistReq) (r *content.GetFileIsExistResp, err error) {
	var _args GetFileIsExistArgs
	_args.Req = Req
	var _result GetFileIsExistResult
	if err = p.c.Call(ctx, "GetFileIsExist", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFile(ctx context.Context, Req *content.GetFileReq) (r *content.GetFileResp, err error) {
	var _args GetFileArgs
	_args.Req = Req
	var _result GetFileResult
	if err = p.c.Call(ctx, "GetFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileList(ctx context.Context, Req *content.GetFileListReq) (r *content.GetFileListResp, err error) {
	var _args GetFileListArgs
	_args.Req = Req
	var _result GetFileListResult
	if err = p.c.Call(ctx, "GetFileList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileCount(ctx context.Context, Req *content.GetFileCountReq) (r *content.GetFileCountResp, err error) {
	var _args GetFileCountArgs
	_args.Req = Req
	var _result GetFileCountResult
	if err = p.c.Call(ctx, "GetFileCount", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileBySharingCode(ctx context.Context, Req *content.GetFileBySharingCodeReq) (r *content.GetFileBySharingCodeResp, err error) {
	var _args GetFileBySharingCodeArgs
	_args.Req = Req
	var _result GetFileBySharingCodeResult
	if err = p.c.Call(ctx, "GetFileBySharingCode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFolderSize(ctx context.Context, Req *content.GetFolderSizeReq) (r *content.GetFolderSizeResp, err error) {
	var _args GetFolderSizeArgs
	_args.Req = Req
	var _result GetFolderSizeResult
	if err = p.c.Call(ctx, "GetFolderSize", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateFolder(ctx context.Context, Req *content.CreateFolderReq) (r *content.CreateFolderResp, err error) {
	var _args CreateFolderArgs
	_args.Req = Req
	var _result CreateFolderResult
	if err = p.c.Call(ctx, "CreateFolder", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateFile(ctx context.Context, Req *content.UpdateFileReq) (r *content.UpdateFileResp, err error) {
	var _args UpdateFileArgs
	_args.Req = Req
	var _result UpdateFileResult
	if err = p.c.Call(ctx, "UpdateFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MoveFile(ctx context.Context, Req *content.MoveFileReq) (r *content.MoveFileResp, err error) {
	var _args MoveFileArgs
	_args.Req = Req
	var _result MoveFileResult
	if err = p.c.Call(ctx, "MoveFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AskUploadFile(ctx context.Context, Req *content.AskUploadFileReq) (r *content.AskUploadFileResp, err error) {
	var _args AskUploadFileArgs
	_args.Req = Req
	var _result AskUploadFileResult
	if err = p.c.Call(ctx, "AskUploadFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AskUploadFileRollback(ctx context.Context, Req *content.AskUploadFileReq) (r *content.AskUploadFileResp, err error) {
	var _args AskUploadFileRollbackArgs
	_args.Req = Req
	var _result AskUploadFileRollbackResult
	if err = p.c.Call(ctx, "AskUploadFileRollback", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteFile(ctx context.Context, Req *content.DeleteFileReq) (r *content.DeleteFileResp, err error) {
	var _args DeleteFileArgs
	_args.Req = Req
	var _result DeleteFileResult
	if err = p.c.Call(ctx, "DeleteFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteShareFile(ctx context.Context, Req *content.DeleteShareFileReq) (r *content.DeleteShareFileResp, err error) {
	var _args DeleteShareFileArgs
	_args.Req = Req
	var _result DeleteShareFileResult
	if err = p.c.Call(ctx, "DeleteShareFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteExpiredFiles(ctx context.Context, Req *content.DeleteExpiredFilesReq) (r *content.DeleteExpiredFilesResp, err error) {
	var _args DeleteExpiredFilesArgs
	_args.Req = Req
	var _result DeleteExpiredFilesResult
	if err = p.c.Call(ctx, "DeleteExpiredFiles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteExpiredShareCodes(ctx context.Context, Req *content.DeleteExpiredShareCodesReq) (r *content.DeleteExpiredShareCodesResp, err error) {
	var _args DeleteExpiredShareCodesArgs
	_args.Req = Req
	var _result DeleteExpiredShareCodesResult
	if err = p.c.Call(ctx, "DeleteExpiredShareCodes", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetLabel(ctx context.Context, Req *content.GetLabelReq) (r *content.GetLabelResp, err error) {
	var _args GetLabelArgs
	_args.Req = Req
	var _result GetLabelResult
	if err = p.c.Call(ctx, "GetLabel", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateLabel(ctx context.Context, Req *content.CreateLabelReq) (r *content.CreateLabelResp, err error) {
	var _args CreateLabelArgs
	_args.Req = Req
	var _result CreateLabelResult
	if err = p.c.Call(ctx, "CreateLabel", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateLabel(ctx context.Context, Req *content.UpdateLabelReq) (r *content.UpdateLabelResp, err error) {
	var _args UpdateLabelArgs
	_args.Req = Req
	var _result UpdateLabelResult
	if err = p.c.Call(ctx, "UpdateLabel", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteLabel(ctx context.Context, Req *content.DeleteLabelReq) (r *content.DeleteLabelResp, err error) {
	var _args DeleteLabelArgs
	_args.Req = Req
	var _result DeleteLabelResult
	if err = p.c.Call(ctx, "DeleteLabel", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
