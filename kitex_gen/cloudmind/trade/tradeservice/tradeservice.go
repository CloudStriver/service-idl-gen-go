// Code generated by Kitex v0.8.0. DO NOT EDIT.

package tradeservice

import (
	"context"
	trade "github.com/CloudStriver/service-idl-gen-go/kitex_gen/cloudmind/trade"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return tradeServiceServiceInfo
}

var tradeServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "TradeService"
	handlerType := (*trade.TradeService)(nil)
	methods := map[string]kitex.MethodInfo{
		"UpdateBalance": kitex.NewMethodInfo(updateBalanceHandler, newUpdateBalanceArgs, newUpdateBalanceResult, false),
		"GetBalance":    kitex.NewMethodInfo(getBalanceHandler, newGetBalanceArgs, newGetBalanceResult, false),
		"CreateBalance": kitex.NewMethodInfo(createBalanceHandler, newCreateBalanceArgs, newCreateBalanceResult, false),
		"AddStock":      kitex.NewMethodInfo(addStockHandler, newAddStockArgs, newAddStockResult, false),
		"GetStock":      kitex.NewMethodInfo(getStockHandler, newGetStockArgs, newGetStockResult, false),
		"GetStocks":     kitex.NewMethodInfo(getStocksHandler, newGetStocksArgs, newGetStocksResult, false),
	}
	extra := map[string]interface{}{
		"PackageName":     "cloudmind.trade",
		"ServiceFilePath": ``,
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.8.0",
		Extra:           extra,
	}
	return svcInfo
}

func updateBalanceHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(trade.UpdateBalanceReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(trade.TradeService).UpdateBalance(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateBalanceArgs:
		success, err := handler.(trade.TradeService).UpdateBalance(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateBalanceResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateBalanceArgs() interface{} {
	return &UpdateBalanceArgs{}
}

func newUpdateBalanceResult() interface{} {
	return &UpdateBalanceResult{}
}

type UpdateBalanceArgs struct {
	Req *trade.UpdateBalanceReq
}

func (p *UpdateBalanceArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(trade.UpdateBalanceReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateBalanceArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateBalanceArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateBalanceArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateBalanceArgs) Unmarshal(in []byte) error {
	msg := new(trade.UpdateBalanceReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateBalanceArgs_Req_DEFAULT *trade.UpdateBalanceReq

func (p *UpdateBalanceArgs) GetReq() *trade.UpdateBalanceReq {
	if !p.IsSetReq() {
		return UpdateBalanceArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateBalanceArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateBalanceArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateBalanceResult struct {
	Success *trade.UpdateBalanceResp
}

var UpdateBalanceResult_Success_DEFAULT *trade.UpdateBalanceResp

func (p *UpdateBalanceResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(trade.UpdateBalanceResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateBalanceResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateBalanceResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateBalanceResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateBalanceResult) Unmarshal(in []byte) error {
	msg := new(trade.UpdateBalanceResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateBalanceResult) GetSuccess() *trade.UpdateBalanceResp {
	if !p.IsSetSuccess() {
		return UpdateBalanceResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateBalanceResult) SetSuccess(x interface{}) {
	p.Success = x.(*trade.UpdateBalanceResp)
}

func (p *UpdateBalanceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateBalanceResult) GetResult() interface{} {
	return p.Success
}

func getBalanceHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(trade.GetBalanceReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(trade.TradeService).GetBalance(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetBalanceArgs:
		success, err := handler.(trade.TradeService).GetBalance(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetBalanceResult)
		realResult.Success = success
	}
	return nil
}
func newGetBalanceArgs() interface{} {
	return &GetBalanceArgs{}
}

func newGetBalanceResult() interface{} {
	return &GetBalanceResult{}
}

type GetBalanceArgs struct {
	Req *trade.GetBalanceReq
}

func (p *GetBalanceArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(trade.GetBalanceReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetBalanceArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetBalanceArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetBalanceArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetBalanceArgs) Unmarshal(in []byte) error {
	msg := new(trade.GetBalanceReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetBalanceArgs_Req_DEFAULT *trade.GetBalanceReq

func (p *GetBalanceArgs) GetReq() *trade.GetBalanceReq {
	if !p.IsSetReq() {
		return GetBalanceArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetBalanceArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetBalanceArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetBalanceResult struct {
	Success *trade.GetBalanceResp
}

var GetBalanceResult_Success_DEFAULT *trade.GetBalanceResp

func (p *GetBalanceResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(trade.GetBalanceResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetBalanceResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetBalanceResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetBalanceResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetBalanceResult) Unmarshal(in []byte) error {
	msg := new(trade.GetBalanceResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetBalanceResult) GetSuccess() *trade.GetBalanceResp {
	if !p.IsSetSuccess() {
		return GetBalanceResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetBalanceResult) SetSuccess(x interface{}) {
	p.Success = x.(*trade.GetBalanceResp)
}

func (p *GetBalanceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetBalanceResult) GetResult() interface{} {
	return p.Success
}

func createBalanceHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(trade.CreateBalanceReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(trade.TradeService).CreateBalance(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateBalanceArgs:
		success, err := handler.(trade.TradeService).CreateBalance(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateBalanceResult)
		realResult.Success = success
	}
	return nil
}
func newCreateBalanceArgs() interface{} {
	return &CreateBalanceArgs{}
}

func newCreateBalanceResult() interface{} {
	return &CreateBalanceResult{}
}

type CreateBalanceArgs struct {
	Req *trade.CreateBalanceReq
}

func (p *CreateBalanceArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(trade.CreateBalanceReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateBalanceArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateBalanceArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateBalanceArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateBalanceArgs) Unmarshal(in []byte) error {
	msg := new(trade.CreateBalanceReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateBalanceArgs_Req_DEFAULT *trade.CreateBalanceReq

func (p *CreateBalanceArgs) GetReq() *trade.CreateBalanceReq {
	if !p.IsSetReq() {
		return CreateBalanceArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateBalanceArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateBalanceArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateBalanceResult struct {
	Success *trade.CreateBalanceResp
}

var CreateBalanceResult_Success_DEFAULT *trade.CreateBalanceResp

func (p *CreateBalanceResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(trade.CreateBalanceResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateBalanceResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateBalanceResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateBalanceResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateBalanceResult) Unmarshal(in []byte) error {
	msg := new(trade.CreateBalanceResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateBalanceResult) GetSuccess() *trade.CreateBalanceResp {
	if !p.IsSetSuccess() {
		return CreateBalanceResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateBalanceResult) SetSuccess(x interface{}) {
	p.Success = x.(*trade.CreateBalanceResp)
}

func (p *CreateBalanceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateBalanceResult) GetResult() interface{} {
	return p.Success
}

func addStockHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(trade.AddStockReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(trade.TradeService).AddStock(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AddStockArgs:
		success, err := handler.(trade.TradeService).AddStock(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddStockResult)
		realResult.Success = success
	}
	return nil
}
func newAddStockArgs() interface{} {
	return &AddStockArgs{}
}

func newAddStockResult() interface{} {
	return &AddStockResult{}
}

type AddStockArgs struct {
	Req *trade.AddStockReq
}

func (p *AddStockArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(trade.AddStockReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AddStockArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AddStockArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AddStockArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AddStockArgs) Unmarshal(in []byte) error {
	msg := new(trade.AddStockReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddStockArgs_Req_DEFAULT *trade.AddStockReq

func (p *AddStockArgs) GetReq() *trade.AddStockReq {
	if !p.IsSetReq() {
		return AddStockArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddStockArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AddStockArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AddStockResult struct {
	Success *trade.AddStockResp
}

var AddStockResult_Success_DEFAULT *trade.AddStockResp

func (p *AddStockResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(trade.AddStockResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AddStockResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AddStockResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AddStockResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AddStockResult) Unmarshal(in []byte) error {
	msg := new(trade.AddStockResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddStockResult) GetSuccess() *trade.AddStockResp {
	if !p.IsSetSuccess() {
		return AddStockResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddStockResult) SetSuccess(x interface{}) {
	p.Success = x.(*trade.AddStockResp)
}

func (p *AddStockResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AddStockResult) GetResult() interface{} {
	return p.Success
}

func getStockHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(trade.GetStockReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(trade.TradeService).GetStock(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetStockArgs:
		success, err := handler.(trade.TradeService).GetStock(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetStockResult)
		realResult.Success = success
	}
	return nil
}
func newGetStockArgs() interface{} {
	return &GetStockArgs{}
}

func newGetStockResult() interface{} {
	return &GetStockResult{}
}

type GetStockArgs struct {
	Req *trade.GetStockReq
}

func (p *GetStockArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(trade.GetStockReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetStockArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetStockArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetStockArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetStockArgs) Unmarshal(in []byte) error {
	msg := new(trade.GetStockReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetStockArgs_Req_DEFAULT *trade.GetStockReq

func (p *GetStockArgs) GetReq() *trade.GetStockReq {
	if !p.IsSetReq() {
		return GetStockArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetStockArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetStockArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetStockResult struct {
	Success *trade.GetStockResp
}

var GetStockResult_Success_DEFAULT *trade.GetStockResp

func (p *GetStockResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(trade.GetStockResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetStockResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetStockResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetStockResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetStockResult) Unmarshal(in []byte) error {
	msg := new(trade.GetStockResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetStockResult) GetSuccess() *trade.GetStockResp {
	if !p.IsSetSuccess() {
		return GetStockResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetStockResult) SetSuccess(x interface{}) {
	p.Success = x.(*trade.GetStockResp)
}

func (p *GetStockResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetStockResult) GetResult() interface{} {
	return p.Success
}

func getStocksHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(trade.GetStocksReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(trade.TradeService).GetStocks(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetStocksArgs:
		success, err := handler.(trade.TradeService).GetStocks(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetStocksResult)
		realResult.Success = success
	}
	return nil
}
func newGetStocksArgs() interface{} {
	return &GetStocksArgs{}
}

func newGetStocksResult() interface{} {
	return &GetStocksResult{}
}

type GetStocksArgs struct {
	Req *trade.GetStocksReq
}

func (p *GetStocksArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(trade.GetStocksReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetStocksArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetStocksArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetStocksArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetStocksArgs) Unmarshal(in []byte) error {
	msg := new(trade.GetStocksReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetStocksArgs_Req_DEFAULT *trade.GetStocksReq

func (p *GetStocksArgs) GetReq() *trade.GetStocksReq {
	if !p.IsSetReq() {
		return GetStocksArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetStocksArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetStocksArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetStocksResult struct {
	Success *trade.GetStocksResp
}

var GetStocksResult_Success_DEFAULT *trade.GetStocksResp

func (p *GetStocksResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(trade.GetStocksResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetStocksResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetStocksResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetStocksResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetStocksResult) Unmarshal(in []byte) error {
	msg := new(trade.GetStocksResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetStocksResult) GetSuccess() *trade.GetStocksResp {
	if !p.IsSetSuccess() {
		return GetStocksResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetStocksResult) SetSuccess(x interface{}) {
	p.Success = x.(*trade.GetStocksResp)
}

func (p *GetStocksResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetStocksResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) UpdateBalance(ctx context.Context, Req *trade.UpdateBalanceReq) (r *trade.UpdateBalanceResp, err error) {
	var _args UpdateBalanceArgs
	_args.Req = Req
	var _result UpdateBalanceResult
	if err = p.c.Call(ctx, "UpdateBalance", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetBalance(ctx context.Context, Req *trade.GetBalanceReq) (r *trade.GetBalanceResp, err error) {
	var _args GetBalanceArgs
	_args.Req = Req
	var _result GetBalanceResult
	if err = p.c.Call(ctx, "GetBalance", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateBalance(ctx context.Context, Req *trade.CreateBalanceReq) (r *trade.CreateBalanceResp, err error) {
	var _args CreateBalanceArgs
	_args.Req = Req
	var _result CreateBalanceResult
	if err = p.c.Call(ctx, "CreateBalance", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddStock(ctx context.Context, Req *trade.AddStockReq) (r *trade.AddStockResp, err error) {
	var _args AddStockArgs
	_args.Req = Req
	var _result AddStockResult
	if err = p.c.Call(ctx, "AddStock", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetStock(ctx context.Context, Req *trade.GetStockReq) (r *trade.GetStockResp, err error) {
	var _args GetStockArgs
	_args.Req = Req
	var _result GetStockResult
	if err = p.c.Call(ctx, "GetStock", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetStocks(ctx context.Context, Req *trade.GetStocksReq) (r *trade.GetStocksResp, err error) {
	var _args GetStocksArgs
	_args.Req = Req
	var _result GetStocksResult
	if err = p.c.Call(ctx, "GetStocks", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
