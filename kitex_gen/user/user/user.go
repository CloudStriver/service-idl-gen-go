// Code generated by Kitex v0.8.0. DO NOT EDIT.

package user

import (
	"context"
	user "github.com/CloudStriver/service-idl-gen-go/kitex_gen/user"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return userServiceInfo
}

var userServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "user"
	handlerType := (*user.User)(nil)
	methods := map[string]kitex.MethodInfo{
		"SendEmailCode":    kitex.NewMethodInfo(sendEmailCodeHandler, newSendEmailCodeArgs, newSendEmailCodeResult, false),
		"Login":            kitex.NewMethodInfo(loginHandler, newLoginArgs, newLoginResult, false),
		"UpdateUser":       kitex.NewMethodInfo(updateUserHandler, newUpdateUserArgs, newUpdateUserResult, false),
		"GetUser":          kitex.NewMethodInfo(getUserHandler, newGetUserArgs, newGetUserResult, false),
		"Register":         kitex.NewMethodInfo(registerHandler, newRegisterArgs, newRegisterResult, false),
		"GenerateToken":    kitex.NewMethodInfo(generateTokenHandler, newGenerateTokenArgs, newGenerateTokenResult, false),
		"RefreshToken":     kitex.NewMethodInfo(refreshTokenHandler, newRefreshTokenArgs, newRefreshTokenResult, false),
		"GetCaptcha":       kitex.NewMethodInfo(getCaptchaHandler, newGetCaptchaArgs, newGetCaptchaResult, false),
		"ConfirmCaptcha":   kitex.NewMethodInfo(confirmCaptchaHandler, newConfirmCaptchaArgs, newConfirmCaptchaResult, false),
		"ConfirmEmailCode": kitex.NewMethodInfo(confirmEmailCodeHandler, newConfirmEmailCodeArgs, newConfirmEmailCodeResult, false),
		"RetrievePassword": kitex.NewMethodInfo(retrievePasswordHandler, newRetrievePasswordArgs, newRetrievePasswordResult, false),
		"SearchUser":       kitex.NewMethodInfo(searchUserHandler, newSearchUserArgs, newSearchUserResult, false),
	}
	extra := map[string]interface{}{
		"PackageName":     "user",
		"ServiceFilePath": ``,
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.8.0",
		Extra:           extra,
	}
	return svcInfo
}

func sendEmailCodeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SendEmailCodeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).SendEmailCode(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SendEmailCodeArgs:
		success, err := handler.(user.User).SendEmailCode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SendEmailCodeResult)
		realResult.Success = success
	}
	return nil
}
func newSendEmailCodeArgs() interface{} {
	return &SendEmailCodeArgs{}
}

func newSendEmailCodeResult() interface{} {
	return &SendEmailCodeResult{}
}

type SendEmailCodeArgs struct {
	Req *user.SendEmailCodeReq
}

func (p *SendEmailCodeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.SendEmailCodeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *SendEmailCodeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *SendEmailCodeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *SendEmailCodeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SendEmailCodeArgs) Unmarshal(in []byte) error {
	msg := new(user.SendEmailCodeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SendEmailCodeArgs_Req_DEFAULT *user.SendEmailCodeReq

func (p *SendEmailCodeArgs) GetReq() *user.SendEmailCodeReq {
	if !p.IsSetReq() {
		return SendEmailCodeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SendEmailCodeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SendEmailCodeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SendEmailCodeResult struct {
	Success *user.SendEmailCodeResp
}

var SendEmailCodeResult_Success_DEFAULT *user.SendEmailCodeResp

func (p *SendEmailCodeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.SendEmailCodeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *SendEmailCodeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *SendEmailCodeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *SendEmailCodeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SendEmailCodeResult) Unmarshal(in []byte) error {
	msg := new(user.SendEmailCodeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SendEmailCodeResult) GetSuccess() *user.SendEmailCodeResp {
	if !p.IsSetSuccess() {
		return SendEmailCodeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SendEmailCodeResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.SendEmailCodeResp)
}

func (p *SendEmailCodeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendEmailCodeResult) GetResult() interface{} {
	return p.Success
}

func loginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.LoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).Login(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *LoginArgs:
		success, err := handler.(user.User).Login(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LoginResult)
		realResult.Success = success
	}
	return nil
}
func newLoginArgs() interface{} {
	return &LoginArgs{}
}

func newLoginResult() interface{} {
	return &LoginResult{}
}

type LoginArgs struct {
	Req *user.LoginReq
}

func (p *LoginArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.LoginReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *LoginArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *LoginArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *LoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LoginArgs) Unmarshal(in []byte) error {
	msg := new(user.LoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LoginArgs_Req_DEFAULT *user.LoginReq

func (p *LoginArgs) GetReq() *user.LoginReq {
	if !p.IsSetReq() {
		return LoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LoginResult struct {
	Success *user.LoginResp
}

var LoginResult_Success_DEFAULT *user.LoginResp

func (p *LoginResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.LoginResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *LoginResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *LoginResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *LoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return LoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *LoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LoginResult) GetResult() interface{} {
	return p.Success
}

func updateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.UpdateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).UpdateUser(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateUserArgs:
		success, err := handler.(user.User).UpdateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateUserResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateUserArgs() interface{} {
	return &UpdateUserArgs{}
}

func newUpdateUserResult() interface{} {
	return &UpdateUserResult{}
}

type UpdateUserArgs struct {
	Req *user.UpdateUserReq
}

func (p *UpdateUserArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.UpdateUserReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateUserArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateUserArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateUserArgs) Unmarshal(in []byte) error {
	msg := new(user.UpdateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateUserArgs_Req_DEFAULT *user.UpdateUserReq

func (p *UpdateUserArgs) GetReq() *user.UpdateUserReq {
	if !p.IsSetReq() {
		return UpdateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateUserResult struct {
	Success *user.UpdateUserResp
}

var UpdateUserResult_Success_DEFAULT *user.UpdateUserResp

func (p *UpdateUserResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.UpdateUserResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateUserResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateUserResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateUserResult) Unmarshal(in []byte) error {
	msg := new(user.UpdateUserResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateUserResult) GetSuccess() *user.UpdateUserResp {
	if !p.IsSetSuccess() {
		return UpdateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.UpdateUserResp)
}

func (p *UpdateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserResult) GetResult() interface{} {
	return p.Success
}

func getUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GetUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).GetUser(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetUserArgs:
		success, err := handler.(user.User).GetUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserResult)
		realResult.Success = success
	}
	return nil
}
func newGetUserArgs() interface{} {
	return &GetUserArgs{}
}

func newGetUserResult() interface{} {
	return &GetUserResult{}
}

type GetUserArgs struct {
	Req *user.GetUserReq
}

func (p *GetUserArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.GetUserReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetUserArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetUserArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserArgs) Unmarshal(in []byte) error {
	msg := new(user.GetUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserArgs_Req_DEFAULT *user.GetUserReq

func (p *GetUserArgs) GetReq() *user.GetUserReq {
	if !p.IsSetReq() {
		return GetUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserResult struct {
	Success *user.GetUserResp
}

var GetUserResult_Success_DEFAULT *user.GetUserResp

func (p *GetUserResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.GetUserResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetUserResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetUserResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserResult) Unmarshal(in []byte) error {
	msg := new(user.GetUserResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserResult) GetSuccess() *user.GetUserResp {
	if !p.IsSetSuccess() {
		return GetUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.GetUserResp)
}

func (p *GetUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserResult) GetResult() interface{} {
	return p.Success
}

func registerHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.RegisterReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).Register(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RegisterArgs:
		success, err := handler.(user.User).Register(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RegisterResult)
		realResult.Success = success
	}
	return nil
}
func newRegisterArgs() interface{} {
	return &RegisterArgs{}
}

func newRegisterResult() interface{} {
	return &RegisterResult{}
}

type RegisterArgs struct {
	Req *user.RegisterReq
}

func (p *RegisterArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.RegisterReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RegisterArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RegisterArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RegisterArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RegisterArgs) Unmarshal(in []byte) error {
	msg := new(user.RegisterReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RegisterArgs_Req_DEFAULT *user.RegisterReq

func (p *RegisterArgs) GetReq() *user.RegisterReq {
	if !p.IsSetReq() {
		return RegisterArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RegisterArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RegisterArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RegisterResult struct {
	Success *user.RegisterResp
}

var RegisterResult_Success_DEFAULT *user.RegisterResp

func (p *RegisterResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.RegisterResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RegisterResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RegisterResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RegisterResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RegisterResult) Unmarshal(in []byte) error {
	msg := new(user.RegisterResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RegisterResult) GetSuccess() *user.RegisterResp {
	if !p.IsSetSuccess() {
		return RegisterResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RegisterResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.RegisterResp)
}

func (p *RegisterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RegisterResult) GetResult() interface{} {
	return p.Success
}

func generateTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GenerateTokenReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).GenerateToken(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GenerateTokenArgs:
		success, err := handler.(user.User).GenerateToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GenerateTokenResult)
		realResult.Success = success
	}
	return nil
}
func newGenerateTokenArgs() interface{} {
	return &GenerateTokenArgs{}
}

func newGenerateTokenResult() interface{} {
	return &GenerateTokenResult{}
}

type GenerateTokenArgs struct {
	Req *user.GenerateTokenReq
}

func (p *GenerateTokenArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.GenerateTokenReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GenerateTokenArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GenerateTokenArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GenerateTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GenerateTokenArgs) Unmarshal(in []byte) error {
	msg := new(user.GenerateTokenReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GenerateTokenArgs_Req_DEFAULT *user.GenerateTokenReq

func (p *GenerateTokenArgs) GetReq() *user.GenerateTokenReq {
	if !p.IsSetReq() {
		return GenerateTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GenerateTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GenerateTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GenerateTokenResult struct {
	Success *user.GenerateTokenResp
}

var GenerateTokenResult_Success_DEFAULT *user.GenerateTokenResp

func (p *GenerateTokenResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.GenerateTokenResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GenerateTokenResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GenerateTokenResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GenerateTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GenerateTokenResult) Unmarshal(in []byte) error {
	msg := new(user.GenerateTokenResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GenerateTokenResult) GetSuccess() *user.GenerateTokenResp {
	if !p.IsSetSuccess() {
		return GenerateTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GenerateTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.GenerateTokenResp)
}

func (p *GenerateTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GenerateTokenResult) GetResult() interface{} {
	return p.Success
}

func refreshTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.RefreshTokenReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).RefreshToken(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RefreshTokenArgs:
		success, err := handler.(user.User).RefreshToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RefreshTokenResult)
		realResult.Success = success
	}
	return nil
}
func newRefreshTokenArgs() interface{} {
	return &RefreshTokenArgs{}
}

func newRefreshTokenResult() interface{} {
	return &RefreshTokenResult{}
}

type RefreshTokenArgs struct {
	Req *user.RefreshTokenReq
}

func (p *RefreshTokenArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.RefreshTokenReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RefreshTokenArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RefreshTokenArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RefreshTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RefreshTokenArgs) Unmarshal(in []byte) error {
	msg := new(user.RefreshTokenReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RefreshTokenArgs_Req_DEFAULT *user.RefreshTokenReq

func (p *RefreshTokenArgs) GetReq() *user.RefreshTokenReq {
	if !p.IsSetReq() {
		return RefreshTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RefreshTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RefreshTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RefreshTokenResult struct {
	Success *user.RefreshTokenResp
}

var RefreshTokenResult_Success_DEFAULT *user.RefreshTokenResp

func (p *RefreshTokenResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.RefreshTokenResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RefreshTokenResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RefreshTokenResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RefreshTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RefreshTokenResult) Unmarshal(in []byte) error {
	msg := new(user.RefreshTokenResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RefreshTokenResult) GetSuccess() *user.RefreshTokenResp {
	if !p.IsSetSuccess() {
		return RefreshTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RefreshTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.RefreshTokenResp)
}

func (p *RefreshTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RefreshTokenResult) GetResult() interface{} {
	return p.Success
}

func getCaptchaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GetCaptchaReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).GetCaptcha(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetCaptchaArgs:
		success, err := handler.(user.User).GetCaptcha(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetCaptchaResult)
		realResult.Success = success
	}
	return nil
}
func newGetCaptchaArgs() interface{} {
	return &GetCaptchaArgs{}
}

func newGetCaptchaResult() interface{} {
	return &GetCaptchaResult{}
}

type GetCaptchaArgs struct {
	Req *user.GetCaptchaReq
}

func (p *GetCaptchaArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.GetCaptchaReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetCaptchaArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetCaptchaArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetCaptchaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetCaptchaArgs) Unmarshal(in []byte) error {
	msg := new(user.GetCaptchaReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetCaptchaArgs_Req_DEFAULT *user.GetCaptchaReq

func (p *GetCaptchaArgs) GetReq() *user.GetCaptchaReq {
	if !p.IsSetReq() {
		return GetCaptchaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetCaptchaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetCaptchaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetCaptchaResult struct {
	Success *user.GetCaptchaResp
}

var GetCaptchaResult_Success_DEFAULT *user.GetCaptchaResp

func (p *GetCaptchaResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.GetCaptchaResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetCaptchaResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetCaptchaResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetCaptchaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetCaptchaResult) Unmarshal(in []byte) error {
	msg := new(user.GetCaptchaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetCaptchaResult) GetSuccess() *user.GetCaptchaResp {
	if !p.IsSetSuccess() {
		return GetCaptchaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetCaptchaResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.GetCaptchaResp)
}

func (p *GetCaptchaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetCaptchaResult) GetResult() interface{} {
	return p.Success
}

func confirmCaptchaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ConfirmCaptchaReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).ConfirmCaptcha(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ConfirmCaptchaArgs:
		success, err := handler.(user.User).ConfirmCaptcha(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ConfirmCaptchaResult)
		realResult.Success = success
	}
	return nil
}
func newConfirmCaptchaArgs() interface{} {
	return &ConfirmCaptchaArgs{}
}

func newConfirmCaptchaResult() interface{} {
	return &ConfirmCaptchaResult{}
}

type ConfirmCaptchaArgs struct {
	Req *user.ConfirmCaptchaReq
}

func (p *ConfirmCaptchaArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.ConfirmCaptchaReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ConfirmCaptchaArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ConfirmCaptchaArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ConfirmCaptchaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ConfirmCaptchaArgs) Unmarshal(in []byte) error {
	msg := new(user.ConfirmCaptchaReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ConfirmCaptchaArgs_Req_DEFAULT *user.ConfirmCaptchaReq

func (p *ConfirmCaptchaArgs) GetReq() *user.ConfirmCaptchaReq {
	if !p.IsSetReq() {
		return ConfirmCaptchaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ConfirmCaptchaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ConfirmCaptchaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ConfirmCaptchaResult struct {
	Success *user.ConfirmCaptchaResp
}

var ConfirmCaptchaResult_Success_DEFAULT *user.ConfirmCaptchaResp

func (p *ConfirmCaptchaResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.ConfirmCaptchaResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ConfirmCaptchaResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ConfirmCaptchaResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ConfirmCaptchaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ConfirmCaptchaResult) Unmarshal(in []byte) error {
	msg := new(user.ConfirmCaptchaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ConfirmCaptchaResult) GetSuccess() *user.ConfirmCaptchaResp {
	if !p.IsSetSuccess() {
		return ConfirmCaptchaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ConfirmCaptchaResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.ConfirmCaptchaResp)
}

func (p *ConfirmCaptchaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ConfirmCaptchaResult) GetResult() interface{} {
	return p.Success
}

func confirmEmailCodeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ConfirmEmailCodeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).ConfirmEmailCode(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ConfirmEmailCodeArgs:
		success, err := handler.(user.User).ConfirmEmailCode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ConfirmEmailCodeResult)
		realResult.Success = success
	}
	return nil
}
func newConfirmEmailCodeArgs() interface{} {
	return &ConfirmEmailCodeArgs{}
}

func newConfirmEmailCodeResult() interface{} {
	return &ConfirmEmailCodeResult{}
}

type ConfirmEmailCodeArgs struct {
	Req *user.ConfirmEmailCodeReq
}

func (p *ConfirmEmailCodeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.ConfirmEmailCodeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ConfirmEmailCodeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ConfirmEmailCodeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ConfirmEmailCodeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ConfirmEmailCodeArgs) Unmarshal(in []byte) error {
	msg := new(user.ConfirmEmailCodeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ConfirmEmailCodeArgs_Req_DEFAULT *user.ConfirmEmailCodeReq

func (p *ConfirmEmailCodeArgs) GetReq() *user.ConfirmEmailCodeReq {
	if !p.IsSetReq() {
		return ConfirmEmailCodeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ConfirmEmailCodeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ConfirmEmailCodeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ConfirmEmailCodeResult struct {
	Success *user.ConfirmEmailCodeResp
}

var ConfirmEmailCodeResult_Success_DEFAULT *user.ConfirmEmailCodeResp

func (p *ConfirmEmailCodeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.ConfirmEmailCodeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ConfirmEmailCodeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ConfirmEmailCodeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ConfirmEmailCodeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ConfirmEmailCodeResult) Unmarshal(in []byte) error {
	msg := new(user.ConfirmEmailCodeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ConfirmEmailCodeResult) GetSuccess() *user.ConfirmEmailCodeResp {
	if !p.IsSetSuccess() {
		return ConfirmEmailCodeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ConfirmEmailCodeResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.ConfirmEmailCodeResp)
}

func (p *ConfirmEmailCodeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ConfirmEmailCodeResult) GetResult() interface{} {
	return p.Success
}

func retrievePasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.RetrievePasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).RetrievePassword(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RetrievePasswordArgs:
		success, err := handler.(user.User).RetrievePassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RetrievePasswordResult)
		realResult.Success = success
	}
	return nil
}
func newRetrievePasswordArgs() interface{} {
	return &RetrievePasswordArgs{}
}

func newRetrievePasswordResult() interface{} {
	return &RetrievePasswordResult{}
}

type RetrievePasswordArgs struct {
	Req *user.RetrievePasswordReq
}

func (p *RetrievePasswordArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.RetrievePasswordReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RetrievePasswordArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RetrievePasswordArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RetrievePasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RetrievePasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.RetrievePasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RetrievePasswordArgs_Req_DEFAULT *user.RetrievePasswordReq

func (p *RetrievePasswordArgs) GetReq() *user.RetrievePasswordReq {
	if !p.IsSetReq() {
		return RetrievePasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RetrievePasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RetrievePasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RetrievePasswordResult struct {
	Success *user.RetrievePasswordResp
}

var RetrievePasswordResult_Success_DEFAULT *user.RetrievePasswordResp

func (p *RetrievePasswordResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.RetrievePasswordResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RetrievePasswordResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RetrievePasswordResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RetrievePasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RetrievePasswordResult) Unmarshal(in []byte) error {
	msg := new(user.RetrievePasswordResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RetrievePasswordResult) GetSuccess() *user.RetrievePasswordResp {
	if !p.IsSetSuccess() {
		return RetrievePasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RetrievePasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.RetrievePasswordResp)
}

func (p *RetrievePasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RetrievePasswordResult) GetResult() interface{} {
	return p.Success
}

func searchUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SearchUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.User).SearchUser(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SearchUserArgs:
		success, err := handler.(user.User).SearchUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchUserResult)
		realResult.Success = success
	}
	return nil
}
func newSearchUserArgs() interface{} {
	return &SearchUserArgs{}
}

func newSearchUserResult() interface{} {
	return &SearchUserResult{}
}

type SearchUserArgs struct {
	Req *user.SearchUserReq
}

func (p *SearchUserArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.SearchUserReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *SearchUserArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *SearchUserArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *SearchUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchUserArgs) Unmarshal(in []byte) error {
	msg := new(user.SearchUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchUserArgs_Req_DEFAULT *user.SearchUserReq

func (p *SearchUserArgs) GetReq() *user.SearchUserReq {
	if !p.IsSetReq() {
		return SearchUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchUserResult struct {
	Success *user.SearchUserResp
}

var SearchUserResult_Success_DEFAULT *user.SearchUserResp

func (p *SearchUserResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.SearchUserResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *SearchUserResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *SearchUserResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *SearchUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchUserResult) Unmarshal(in []byte) error {
	msg := new(user.SearchUserResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchUserResult) GetSuccess() *user.SearchUserResp {
	if !p.IsSetSuccess() {
		return SearchUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.SearchUserResp)
}

func (p *SearchUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchUserResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) SendEmailCode(ctx context.Context, Req *user.SendEmailCodeReq) (r *user.SendEmailCodeResp, err error) {
	var _args SendEmailCodeArgs
	_args.Req = Req
	var _result SendEmailCodeResult
	if err = p.c.Call(ctx, "SendEmailCode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Login(ctx context.Context, Req *user.LoginReq) (r *user.LoginResp, err error) {
	var _args LoginArgs
	_args.Req = Req
	var _result LoginResult
	if err = p.c.Call(ctx, "Login", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateUser(ctx context.Context, Req *user.UpdateUserReq) (r *user.UpdateUserResp, err error) {
	var _args UpdateUserArgs
	_args.Req = Req
	var _result UpdateUserResult
	if err = p.c.Call(ctx, "UpdateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUser(ctx context.Context, Req *user.GetUserReq) (r *user.GetUserResp, err error) {
	var _args GetUserArgs
	_args.Req = Req
	var _result GetUserResult
	if err = p.c.Call(ctx, "GetUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Register(ctx context.Context, Req *user.RegisterReq) (r *user.RegisterResp, err error) {
	var _args RegisterArgs
	_args.Req = Req
	var _result RegisterResult
	if err = p.c.Call(ctx, "Register", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GenerateToken(ctx context.Context, Req *user.GenerateTokenReq) (r *user.GenerateTokenResp, err error) {
	var _args GenerateTokenArgs
	_args.Req = Req
	var _result GenerateTokenResult
	if err = p.c.Call(ctx, "GenerateToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RefreshToken(ctx context.Context, Req *user.RefreshTokenReq) (r *user.RefreshTokenResp, err error) {
	var _args RefreshTokenArgs
	_args.Req = Req
	var _result RefreshTokenResult
	if err = p.c.Call(ctx, "RefreshToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetCaptcha(ctx context.Context, Req *user.GetCaptchaReq) (r *user.GetCaptchaResp, err error) {
	var _args GetCaptchaArgs
	_args.Req = Req
	var _result GetCaptchaResult
	if err = p.c.Call(ctx, "GetCaptcha", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ConfirmCaptcha(ctx context.Context, Req *user.ConfirmCaptchaReq) (r *user.ConfirmCaptchaResp, err error) {
	var _args ConfirmCaptchaArgs
	_args.Req = Req
	var _result ConfirmCaptchaResult
	if err = p.c.Call(ctx, "ConfirmCaptcha", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ConfirmEmailCode(ctx context.Context, Req *user.ConfirmEmailCodeReq) (r *user.ConfirmEmailCodeResp, err error) {
	var _args ConfirmEmailCodeArgs
	_args.Req = Req
	var _result ConfirmEmailCodeResult
	if err = p.c.Call(ctx, "ConfirmEmailCode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RetrievePassword(ctx context.Context, Req *user.RetrievePasswordReq) (r *user.RetrievePasswordResp, err error) {
	var _args RetrievePasswordArgs
	_args.Req = Req
	var _result RetrievePasswordResult
	if err = p.c.Call(ctx, "RetrievePassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchUser(ctx context.Context, Req *user.SearchUserReq) (r *user.SearchUserResp, err error) {
	var _args SearchUserArgs
	_args.Req = Req
	var _result SearchUserResult
	if err = p.c.Call(ctx, "SearchUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
